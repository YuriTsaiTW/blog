<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="google-site-verification" content="pZ-aKgYoFLXb0aX2M5bgd0NvdKdH9LWgjUR5X12lD8U"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JSDC 2021 前導活動 | ECMAScript 關鍵 30 天 | Are you ready? ES2022! - Yuri 學習隨筆</title><link rel="manifest" href="/blog/manifest.json"><meta name="application-name" content="Yuri 學習隨筆"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Yuri 學習隨筆"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="前言ECMAScript 原本是不定期地釋出版本，但因應提案的踴躍和開發需求的迫切，所以從 ES2015 後就改為一年一修。也就是說每年都會有新的語法標準出現，讓開發者可以使用更簡潔彈性的語法撰寫，或是實現更強大的功能。"><meta property="og:type" content="blog"><meta property="og:title" content="JSDC 2021 前導活動 | ECMAScript 關鍵 30 天 | Are you ready? ES2022!"><meta property="og:url" content="https://yuritsaitw.github.io/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2021110111/"><meta property="og:site_name" content="Yuri 學習隨筆"><meta property="og:description" content="前言ECMAScript 原本是不定期地釋出版本，但因應提案的踴躍和開發需求的迫切，所以從 ES2015 後就改為一年一修。也就是說每年都會有新的語法標準出現，讓開發者可以使用更簡潔彈性的語法撰寫，或是實現更強大的功能。"><meta property="og:locale" content="zh_TW"><meta property="og:image" content="https://yuritsaitw.github.io/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2021110111/cover.png"><meta property="article:published_time" content="2021-11-01T11:48:41.000Z"><meta property="article:modified_time" content="2023-09-23T06:33:42.569Z"><meta property="article:author" content="Yuri Tsai"><meta property="article:tag" content="JavaScript"><meta property="article:tag" content="ECMAScript"><meta property="article:tag" content="JSDC"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2021110111/cover.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://yuritsaitw.github.io/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2021110111/"},"headline":"Yuri 學習隨筆","image":["https://yuritsaitw.github.io/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2021110111/cover.png"],"datePublished":"2021-11-01T11:48:41.000Z","dateModified":"2023-09-23T06:33:42.569Z","author":{"@type":"Person","name":"Yuri Tsai"},"description":"前言ECMAScript 原本是不定期地釋出版本，但因應提案的踴躍和開發需求的迫切，所以從 ES2015 後就改為一年一修。也就是說每年都會有新的語法標準出現，讓開發者可以使用更簡潔彈性的語法撰寫，或是實現更強大的功能。"}</script><link rel="canonical" href="https://yuritsaitw.github.io/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2021110111/"><link rel="icon" href="/blog/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/blog/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-RB9TX9FZV1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-RB9TX9FZV1');</script><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/blog/"><img src="/blog/img/logo.png" alt="Yuri 學習隨筆" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/blog/">首頁</a><a class="navbar-item" href="/blog/archives">彙整</a><a class="navbar-item" href="/blog/categories">分類</a><a class="navbar-item" href="/blog/tags">標籤</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="請我喝杯咖啡吧💖" href="https://www.buymeacoffee.com/yurijournaltw"><i class="fas fa-coffee"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="文章目錄" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜尋" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2021110111/cover.png" alt="JSDC 2021 前導活動 | ECMAScript 關鍵 30 天 | Are you ready? ES2022!"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-11-01T11:48:41.000Z" title="11/1/2021, 11:48:41 AM">2021-11-01</time>發表</span><span class="level-item"><time dateTime="2023-09-23T06:33:42.569Z" title="9/23/2023, 6:33:42 AM">2023-09-23</time>更新</span><span class="level-item"><a class="link-muted" href="/blog/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/">軟體開發</a></span><span class="level-item">7 分鐘讀完 (大約2387個字)</span></div></div><h1 class="title is-3 is-size-4-mobile">JSDC 2021 前導活動 | ECMAScript 關鍵 30 天 | Are you ready? ES2022!</h1><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ECMAScript 原本是不定期地釋出版本，但因應提案的踴躍和開發需求的迫切，所以從 ES2015 後就改為一年一修。也就是說每年都會有新的語法標準出現，讓開發者可以使用更簡潔彈性的語法撰寫，或是實現更強大的功能。</p>
<span id="more"></span>

<p>接下來整理預計會在 ES2022 釋出的提案，以簡單的說明加上清楚的程式範例，快速了解起手式💪</p>
<h2 id="ECMAScript-提案五階段"><a href="#ECMAScript-提案五階段" class="headerlink" title="ECMAScript 提案五階段"></a>ECMAScript 提案五階段</h2><p>一個想法出來到納入提案，接著成為修訂標準，通常會經歷以下 5 個階段－</p>
<table>
<thead>
<tr>
<th>Stage</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>由 TC－39 的成員或其他人提出後，委員會沒有否決的討論或想法</td>
</tr>
<tr>
<td>1</td>
<td>正式成為提案，需有具體語法和描述，部分會有Polyfill的實現</td>
</tr>
<tr>
<td>2</td>
<td>可能有相關的運作環境或編譯器提供實驗性的功能實現</td>
</tr>
<tr>
<td>3</td>
<td>成為候選提案，部分運作環境或編譯器提供原生支援</td>
</tr>
<tr>
<td><mark>4</mark></td>
<td><mark>通過至少兩個驗收測試，等待下版釋出時成為修訂內容</mark></td>
</tr>
</tbody></table>
<p>今天要講的語法，都是已經進到 finished，也就是 Stage 4 階段的提案。有興趣的話，可以前往 TC－39 的 <a target="_blank" rel="noopener" href="https://github.com/tc39/proposals/blob/master/finished-proposals.md">GitHub</a> 看相關整理。有趣的是，在這裡不僅可以看到語法的開發動機和具體描述，也能看到在提案推進的過程中，開發者與委員們的討論紀錄，可以更進一步地了解標準推出的始末。</p>
<h2 id="正規表達式"><a href="#正規表達式" class="headerlink" title="正規表達式"></a>正規表達式</h2><p><img src="/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2021110111/regexp.png"></p>
<p>先簡單複習一下。正規表達式主要有以下三種組成－</p>
<ul>
<li>以指定的文字加上特殊字元組成匹配的句法。</li>
<li>由兩個雙斜線（&#x2F;）包覆匹配的句法。</li>
<li>後面可以選擇性地加上一個或多個旗標，設定全域的查找規則。</li>
</ul>
<p>其中旗標的部分，一個 RegExp 物件會針對旗標提供實體屬性來查詢。透過取得屬性值，就可以知道這個正規表達式有沒有設定對應的旗標。</p>
<table>
<thead>
<tr>
<th>Stage</th>
<th>對應屬性</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>d</strong></td>
<td>hasIndices</td>
<td>回傳每個匹配內容的起始&amp;下次要開始檢索的索引陣列<br>(<code>[startIndex, endIndex+1]</code>)</td>
</tr>
</tbody></table>
<p>有加上 <code>d</code> 旗標的正規表達式，在執行匹配相關的操作，例如 <code>exec</code> 時，可以多回傳一個 <code>indices</code> 屬性。這個屬性會包含匹配內容的起始索引，以及結束索引加 1，也就是視為下次要開始檢索的索引。</p>
<p>目前最新版本的 Chrome 還有Node.js中可以運作，有興趣的話可以嘗試看看。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myRegexp = <span class="regexp">/\w*.o\w+/</span>dgi; <span class="comment">// 找出中間有 o 的單字</span></span><br><span class="line"><span class="keyword">const</span> target = <span class="string">&#x27;Born to make history&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currResult;</span><br><span class="line"><span class="keyword">while</span> ((currResult = myRegexp.<span class="title function_">exec</span>(target)) !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;這次的符合內容: &#x27;</span>, currResult[<span class="number">0</span>]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Matched Indices: &#x27;</span>, currResult.<span class="property">indices</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 這次的符合內容: Born</span></span><br><span class="line"><span class="comment">// Matched Indices:  (2) [0, 4]</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="comment">// 這次的符合內容: history</span></span><br><span class="line"><span class="comment">// Matched Indices:  (2) [13, 20]</span></span><br><span class="line"><span class="comment">// ---</span></span><br></pre></td></tr></table></figure>

<h2 id="具有索引的標準內建物件"><a href="#具有索引的標準內建物件" class="headerlink" title="具有索引的標準內建物件"></a>具有索引的標準內建物件</h2><p>常見的這類物件有字串跟陣列。那麼在 ES2022 推出了什麼相關語法呢?</p>
<h3 id="indexable-at-index"><a href="#indexable-at-index" class="headerlink" title="indexable.at(index)"></a><code>indexable.at(index)</code></h3><p>用途跟使用字面值取得元素的方式類似，透過索引的傳入來獲得元素。不過索引值在負整數跟浮點數時，跟字面值的回傳結果會不一樣。可以看一嚇得比較表－</p>
<table>
<thead>
<tr>
<th>取得元素的方式</th>
<th>負整數</th>
<th>浮點數</th>
</tr>
</thead>
<tbody><tr>
<td><code>indexable[index]</code></td>
<td><code>undefined</code></td>
<td><code>undefined</code></td>
</tr>
<tr>
<td><code>indexable.at(index)</code></td>
<td>後面從 -1 開始算</td>
<td>無條件捨去後，再由正負數決定查找方向</td>
</tr>
</tbody></table>
<p>目前最新版本的 Chrome 可以運作，有興趣的話可以嘗試看看。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[-<span class="number">2</span>], myArray.<span class="title function_">at</span>(-<span class="number">2</span>)); <span class="comment">// undefined 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[<span class="number">1.6</span>], myArray.<span class="title function_">at</span>(<span class="number">1.6</span>)); <span class="comment">// undefined 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[-<span class="number">3.2</span>], myArray.<span class="title function_">at</span>(-<span class="number">3.2</span>)); <span class="comment">// undefined 1</span></span><br></pre></td></tr></table></figure>

<h2 id="物件"><a href="#物件" class="headerlink" title="物件"></a>物件</h2><h3 id="Object-hasOwn-target-propName"><a href="#Object-hasOwn-target-propName" class="headerlink" title="Object.hasOwn(target, propName)"></a><code>Object.hasOwn(target, propName)</code></h3><p>用來檢查目標物件有沒有屬性。那跟目前習慣使用的 <code>hasOwnProperty</code> 有什麼不一樣呢?</p>
<p>假設以 <code>Object.create(null)</code> 建立了空物件，然後新增一些屬性後，我們想檢查這個物件有沒有特定屬性。可是物件的原型指向了 <code>null</code>，所以就無法使用實體方法 <code>hasOwnProperty</code>，除非要直接呼叫 <code>Object.prototype.hasOwnProperty</code> 加上 <code>call</code> 方法來達到這個目的。不過這樣的寫法太冗長了。因此 ES2022 就在 <code>Object</code> 底下新增這個靜態方法，成為語法糖。</p>
<p>目前最新版本的 Chrome 可以運作，有興趣的話可以嘗試看看。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="keyword">const</span> hasNameProp = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(myObject, <span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">const</span> hasNameProp = <span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(myObject, <span class="string">&#x27;name&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="類別"><a href="#類別" class="headerlink" title="類別"></a>類別</h2><p>類別的相關語法在 ES2022 中占了蠻大一部分的內容。其中可以把這些修訂分類為－</p>
<ul>
<li>擴充靜態關鍵字（static）的使用</li>
<li>正式支援私有（private）的機制</li>
</ul>
<h3 id="靜態方法與成員（Static-methods-and-fields）"><a href="#靜態方法與成員（Static-methods-and-fields）" class="headerlink" title="靜態方法與成員（Static methods and fields）"></a>靜態方法與成員（Static methods and fields）</h3><p>在 ES2015 時提出的 <code>static</code> 關鍵字，只能做為公開靜態方法的前綴字。不過在 ES2022 後，<code>static</code> 關鍵字的應用範圍更廣泛了。無論是屬性或方法，公開或私有，只要在名稱前加上前綴字，就能表示為靜態。</p>
<p>目前最新版本的 Chrome 可以運作，有興趣的話可以嘗試看看。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Inbody</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> #secretNumber = <span class="number">1.2</span>; <span class="comment">// ES2022: 私有靜態成員</span></span><br><span class="line">    <span class="keyword">static</span> brand = <span class="string">&#x27;My Inbody&#x27;</span>; <span class="comment">// ES2022: 公開靜態成員</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ES2022: 私有靜態方法</span></span><br><span class="line">    <span class="keyword">static</span> #<span class="title function_">getPBF</span>(<span class="params">weight, fat</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((fat * <span class="title class_">Person</span>.#secretNumber) / weight) * <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ES2015: 公開靜態方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getBMI</span>(<span class="params">weight, height</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> weight / <span class="title class_">Math</span>.<span class="title function_">pow</span>(height / <span class="number">100</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Inbody</span>.<span class="property">country</span> = <span class="string">&#x27;Taiwan&#x27;</span>; <span class="comment">// ES2015: 公開靜態成員</span></span><br></pre></td></tr></table></figure>

<h3 id="靜態初始化區塊（Static-initialization-blocks）"><a href="#靜態初始化區塊（Static-initialization-blocks）" class="headerlink" title="靜態初始化區塊（Static initialization blocks）"></a>靜態初始化區塊（Static initialization blocks）</h3><p>類別初始化時，有些靜態成員需要透過流程控制設定初始值的話，通常只能在類別建立後，把相關的初始流程放在之後。在程式的語意上會像是兩個獨立的區塊拼在一起，規模越複雜的話，就會降低維護性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">APILibrary</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> configs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchedConfigs = <span class="keyword">await</span> <span class="title function_">fetchConfigs</span>();</span><br><span class="line">    <span class="title class_">APILibrary</span>.<span class="property">configs</span> = &#123; ...fetchedConfigs, <span class="attr">tag</span>: <span class="number">1</span> &#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="title class_">APILibrary</span>.<span class="property">configs</span> = &#123; <span class="attr">root</span>: <span class="string">&#x27;myroot/api&#x27;</span>, <span class="attr">tag</span>: <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES2022後，類別中只要使用 <code>static</code> 關鍵字加上大括號（<code>&#123; &#125;</code>），就能包覆靜態成員的初始流程。這樣做還有個好處是，流程中需要存取類別的私有成員時，可以直接取用，而不用再撰寫額外存取器方法來封裝，寫法上算是優雅很多。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">APILibrary</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> configs;</span><br><span class="line">    <span class="keyword">static</span> #defaultRoot = <span class="string">&#x27;myroot/api&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> fetchedConfigs = <span class="keyword">await</span> <span class="title function_">fetchConfigs</span>();</span><br><span class="line">            <span class="title class_">APILibrary</span>.<span class="property">configs</span> = &#123; ...fetchedConfigs, <span class="attr">tag</span>: <span class="number">1</span> &#125;;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="title class_">APILibrary</span>.<span class="property">configs</span> = &#123; <span class="attr">root</span>: <span class="title class_">APILibrary</span>.#defaultRoot, <span class="attr">tag</span>: <span class="number">2</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定義私有方法與成員（Private-methods-and-fields）"><a href="#定義私有方法與成員（Private-methods-and-fields）" class="headerlink" title="定義私有方法與成員（Private methods and fields）"></a>定義私有方法與成員（Private methods and fields）</h3><p>成為私有成員，表示只有內部可以使用，外部如果嘗試存取或呼叫的話，就會回傳 <code>undefined</code> 或錯誤提示。這樣做可以保護成員不會被外部任意修改，或設定只有內部可以操作的方法等。</p>
<p>在 ES2022 後，正式把 <strong><code>#</code></strong> 作為私有成員的前綴字。像是上面的範例程式－<code>static #defaultRoot = &#39;myroot/api&#39;;</code>，<code>defaultRoot</code> 屬性就是一種私有屬性。</p>
<p>需要注意的是，不只是宣告，在呼叫方法或存取屬性時也需要冠上這個前綴字。更多有關私有方法與成員的範例程式與說明，可以參考我即將上市的書－<a target="_blank" rel="noopener" href="https://www.drmaster.com.tw/Bookinfo.asp?BookID=MP22159">ECMAScript關鍵30天</a>。</p>
<h2 id="頂層的-await"><a href="#頂層的-await" class="headerlink" title="頂層的 await"></a>頂層的 await</h2><p><code>await</code> 跟 <code>async</code> 的語法是非同步處理的語法糖。只要函式中有 <code>await</code> 的關鍵字出現，就一定要在該函式名稱的前面加 <code>async</code> 的前綴字。在 ES2022 後，可以允許在需要非同步的地方加上 <code>await</code> 就好，不需使用async函式封裝，提升了撰寫非同步的彈性與簡潔性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case 1</span></span><br><span class="line"><span class="keyword">import</span> &#123; fetchAppConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;../APILibrary&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> appConfig = <span class="keyword">await</span> <span class="title function_">fetchAppConfig</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// case 2</span></span><br><span class="line"><span class="keyword">const</span> menuData = <span class="title function_">fetch</span>(<span class="string">&#x27;api/config/menu.json&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span></span><br><span class="line">    response.<span class="title function_">json</span>()</span><br><span class="line">);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">await</span> menuData;</span><br></pre></td></tr></table></figure>

<h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>如果有在專案中使用 Babel，並且設定 <code>@babel/preset-env</code> 這個 preset 的話，就可以試試看目前有支援的轉換語法，像是頂層 await、類別的靜態初始化區塊等。</p>
<p><img src="/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2021110111/babel.png"></p>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>如果專案是以 TypeScript 開發，在目前的 beta 版可以透過 <code>tsconfig.json</code> 的 <code>module</code> 設定來支援頂層 await。</p>
<p><img src="/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2021110111/ts.png"></p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這篇文章的內容，主要是擷取自我即將上市的書。如果有興趣的話，也歡迎在 11&#x2F;12 後去天瓏翻翻看，或是在博客來等網站翻一下試閱頁。有對到你的電波的話，歡迎把它帶回家喔😆</p>
<p>這篇內容也有影片版可以觀看。在這裡也謝謝 JSDC 的邀請，讓我有了直播技術分享的初體驗。另外 JSDC 當天的議程內容真的很充實，受益良多。有時間的話，會再陸續整理相關心得。</p>
<iframe width="100%" height="400" src="https://www.youtube.com/embed/ACJk8zHuV1U" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/tc39/proposals/blob/master/finished-proposals.md">TC-39 GitHub &gt; Finished Proposals</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/geekculture/proposals-included-in-the-incoming-ecmascript-2022-standard-for-javascript-6119a4518904">Proposals included in the incoming ECMAScript 2022 standard for JavaScript</a></li>
<li><a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/plugins-list#es2022">Babel Plugin List</a></li>
<li><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-5-beta/#module-es2022">Announcing TypeScript 4.5 Beta</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>JSDC 2021 前導活動 | ECMAScript 關鍵 30 天 | Are you ready? ES2022!</p><p><a href="https://yuritsaitw.github.io/blog/軟體開發/2021110111/">https://yuritsaitw.github.io/blog/軟體開發/2021110111/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Yuri Tsai</p></div></div><div class="level-item is-narrow"><div><h6>發表於</h6><p>2021-11-01</p></div></div><div class="level-item is-narrow"><div><h6>更新於</h6><p>2023-09-23</p></div></div><div class="level-item is-narrow"><div><h6>許可協議</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/blog/tags/JavaScript/">JavaScript</a><a class="link-muted mr-2" rel="tag" href="/blog/tags/ECMAScript/">ECMAScript</a><a class="link-muted mr-2" rel="tag" href="/blog/tags/JSDC/">JSDC</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=603f4a070e267500127ccaef&amp;product=inline-share-buttons" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜歡這篇文章嗎? 贊助一下作者吧!</h3><div class="buttons is-centered"><div class="likecoin-embed likecoin-button"><div></div><iframe scrolling="no" frameborder="0" src="https://button.like.co/in/embed/showwell0120/button?referrer=&lt;%- encodeURIComponent(post.permalink) %&gt;"></iframe></div><a class="button donate" href="https://www.buymeacoffee.com/yurijournaltw" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2021111210/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">WordPress | 架在 IIS 的踩雷紀錄 | Give Me Pretty Permalinks!</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2021102916/"><span class="level-item">ModernWeb&#039;21 | 系列心得文(II) | 5 場讓我印象深刻的議程</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">評論</h3><script src="https://utteranc.es/client.js" repo="showwell0120/utterances-for-blog" issue-term="pathname" label="some-issue-label" theme="github-light" crossorigin="anonymous" async></script></div></div></div><!--!--><div class="column column-right is-3-tablet is-3-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">文章目錄</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#ECMAScript-提案五階段"><span class="level-left"><span class="level-item">2</span><span class="level-item">ECMAScript 提案五階段</span></span></a></li><li><a class="level is-mobile" href="#正規表達式"><span class="level-left"><span class="level-item">3</span><span class="level-item">正規表達式</span></span></a></li><li><a class="level is-mobile" href="#具有索引的標準內建物件"><span class="level-left"><span class="level-item">4</span><span class="level-item">具有索引的標準內建物件</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#indexable-at-index"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">indexable.at(index)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#物件"><span class="level-left"><span class="level-item">5</span><span class="level-item">物件</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Object-hasOwn-target-propName"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">Object.hasOwn(target, propName)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#類別"><span class="level-left"><span class="level-item">6</span><span class="level-item">類別</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#靜態方法與成員（Static-methods-and-fields）"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">靜態方法與成員（Static methods and fields）</span></span></a></li><li><a class="level is-mobile" href="#靜態初始化區塊（Static-initialization-blocks）"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">靜態初始化區塊（Static initialization blocks）</span></span></a></li><li><a class="level is-mobile" href="#定義私有方法與成員（Private-methods-and-fields）"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">定義私有方法與成員（Private methods and fields）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#頂層的-await"><span class="level-left"><span class="level-item">7</span><span class="level-item">頂層的 await</span></span></a></li><li><a class="level is-mobile" href="#Babel"><span class="level-left"><span class="level-item">8</span><span class="level-item">Babel</span></span></a></li><li><a class="level is-mobile" href="#TypeScript"><span class="level-left"><span class="level-item">9</span><span class="level-item">TypeScript</span></span></a></li><li><a class="level is-mobile" href="#小結"><span class="level-left"><span class="level-item">10</span><span class="level-item">小結</span></span></a></li><li><a class="level is-mobile" href="#參考連結"><span class="level-left"><span class="level-item">11</span><span class="level-item">參考連結</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/blog/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/blog/%E8%81%B7%E6%B6%AF%E7%99%BC%E5%B1%95/2023010913/"><img src="/blog/%E8%81%B7%E6%B6%AF%E7%99%BC%E5%B1%95/2023010913/cover.png" alt="第一年的工作回顧 | 熱鬧點科技 Migo"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-01-09T13:38:44.000Z">2023-01-09</time></p><p class="title"><a href="/blog/%E8%81%B7%E6%B6%AF%E7%99%BC%E5%B1%95/2023010913/">第一年的工作回顧 | 熱鬧點科技 Migo</a></p><p class="categories"><a href="/blog/categories/%E8%81%B7%E6%B6%AF%E7%99%BC%E5%B1%95/">職涯發展</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2022061017/"><img src="/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2022061017/cover.jpeg" alt="[譯] #3 React Query 的優化"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-06-10T17:36:18.000Z">2022-06-10</time></p><p class="title"><a href="/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2022061017/">[譯] #3 React Query 的優化</a></p><p class="categories"><a href="/blog/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/">軟體開發</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2022060818/"><img src="/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2022060818/cover.jpeg" alt="[譯] #2 React Query 的資料轉換"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-06-08T18:20:51.000Z">2022-06-08</time></p><p class="title"><a href="/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2022060818/">[譯] #2 React Query 的資料轉換</a></p><p class="categories"><a href="/blog/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/">軟體開發</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2022060716/"><img src="/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2022060716/cover.png" alt="[譯] #1 React Query 的實用技巧"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-06-07T16:22:49.000Z">2022-06-07</time></p><p class="title"><a href="/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2022060716/">[譯] #1 React Query 的實用技巧</a></p><p class="categories"><a href="/blog/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/">軟體開發</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/blog/%E8%81%B7%E6%B6%AF%E7%99%BC%E5%B1%95/2022032211/"><img src="/blog/%E8%81%B7%E6%B6%AF%E7%99%BC%E5%B1%95/2022032211/cover.png" alt="第一次的轉職 | 6 年的工作回顧 | 嘉實資訊 SysJust"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-03-22T11:16:15.000Z">2022-03-22</time></p><p class="title"><a href="/blog/%E8%81%B7%E6%B6%AF%E7%99%BC%E5%B1%95/2022032211/">第一次的轉職 | 6 年的工作回顧 | 嘉實資訊 SysJust</a></p><p class="categories"><a href="/blog/categories/%E8%81%B7%E6%B6%AF%E7%99%BC%E5%B1%95/">職涯發展</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/blog/"><img src="/blog/img/logo.png" alt="Yuri 學習隨筆" height="28"></a><p class="is-size-7"><span>&copy; 2023 Yuri Tsai</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-TW");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/blog/js/column.js"></script><script src="/blog/js/animation.js"></script><a id="back-to-top" title="回到頁首" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/blog/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此網站使用Cookie來改善您的體驗。",
          dismiss: "知道了！",
          allow: "允許使用Cookie",
          deny: "拒絕",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="/blog/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="請輸入關鍵字..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/blog/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/blog/content.json"}, {"hint":"請輸入關鍵字...","untitled":"(無標題)","posts":"文章","pages":"頁面","categories":"分類","tags":"標籤"});
        });</script></body></html>