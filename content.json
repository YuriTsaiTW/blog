{"pages":[],"posts":[{"title":"行動應用｜自動化開發階段的更版流程｜fastlane｜conventional-changelog","text":"Developers love writing React Native code but no one likes deploying React Native app or distributing beta builds. - RNBoilerplate Docs(那些喜愛寫 React Native 的開發者，不會有人喜歡做建置、發布或上架的事情) 前言當專案開發到了雛型階段時，會需要讓開發人員以外的人使用或測試。在 Web 開發中，只需要更新 server 中的靜態檔就能完成；但是在行動應用上，就需要建置出安裝檔，當使用者下載安裝後，才完成更版的動作。 如果完全不靠工具和指令，每次建置、上傳檔案等都親力而為，其實花費不少時間。舉例來說，在 XCode 中產出安裝檔 ipa，需要經過以下步驟： 選擇裝置 Any iOS Device Product &gt; Archive，通常會等 2~3 分 在 Archives 列表視窗中點選 Distribute app 選擇部署方式。例如 Enterprise 選擇 Manually manage signing 選擇 Distribution Certificate &amp; Provision Profile，這時候會再等 1~2 分 點選 Export，選擇輸出目錄 到這裡大概就花了約 5 分鐘了，接著還需要打開 Dropbox，或是自家的空間上傳剛剛建置出的 ipa。為了給測試人員查看有哪些更新，還要再維護安裝頁中的變更紀錄。最後，需要通知有安裝 App 的人已經有新版釋出。 做完一輪這些事情就花了至少 10 分鐘（還不包含建置前要做的版本管理）。如果在開發階段需要頻繁的釋出版本，可能就要比平常晚半小時，甚至一小時才能下班啊 😖 規劃更版流程當你發現同一件事情做了三次以上，未來也會繼續做時，就先停下來吧！ 手動做這些事情，除了浪費時間以外，也很容易增加出錯的機率。例如上傳到錯的檔案、版本標錯等。因此，我們需要仰賴工具，幫我們做這些千篇一律的任務，讓省下來的時間，去做有實際產出、有創造力的事 💪 首先，必須先整理出要需要哪些任務，這些任務的前後關係，以及思考每個任務的執行內容。這部分會根據開發習慣、專案性質、產品開發階段的不同而會有不一樣的流程。只要有想清楚就好，沒有一定的標準。 以我目前接手的專案來說，需要做的是建置雙系統的開發版 App 給內部人員。所以就規劃了以上流程。工具上，我主要會用以下兩種： Conventional Changelog: 為 commit 增加分類、描述、關聯的 issue 等格式化訊息，並產出 CHANGELOG.md 前置準備- 在全域安裝 commitizen 跟 conventional-changelog-clinpm i -g commitizen conventional-changelog-cli 在專案目錄下安裝 cz-conventional-changelognpm i -D cz-conventional-changelog安裝完成後，package.json 會自動加上一段設定package.json12345&quot;config&quot;: { &quot;commitizen&quot;: { &quot;path&quot;: &quot;./App4/node_modules/cz-conventional-changelog&quot; }} fastlane: 提供大量實用的 actions 和 plugins，以 ruby code 和 cli 做到任務的自動化 前置準備- 可以參考 React Native Boilerplate Docs 的Installing Fastlane。重點是要先有 MacOS😅 在 ios 跟 android 的目錄下執行 fastlane init。兩個系統在 setup 時有些許差異，同樣可以參考上面連結。 需要安裝某個 plugin 時，執行 fastlane add_plugin xxx 就可以囉！ 想查詢某個內建 action 或是 plugin 時，可以執行 fastlane action xxx，就可以在command line上看到很清楚的說明文件。 接下來就針對每個任務來分享我的實作方式吧！ 任務實作提交 commit寫一份好的的commit，會幫助我們完成以下事情： 更順暢地 code review 團隊合作的版本控管，讓大家一看就知道那段時間在做什麼 方便準備 release 相關文件(e.g. 產生CHANGELOG.md) 提供 trace code 的線索 為了方便操作，我們可以建立npm指令 package.json123&quot;script&quot;: { &quot;cm&quot;: &quot;npx cz&quot;,} 將想變更的檔案加到stage，執行 npm run cm 後就可以顯示以下畫面： 接著按照每個步驟填入分類、簡述、issue序號等，就可以完成一個有完整資訊的commit囉！ 更新版本無論是 Android 還是 iOS，都會有兩個值去描述版本。由於兩邊的名稱都不太一樣，我這裡就取一致的中文名稱。 版名：建議採Semantic Versioning(major.minor.patch)。 主要用途是在上架商店中會顯示給使用者看。 iOS Android 名稱 Version Number Version Name 格式 建議 Semantic Versioning 同左 版號：建置號碼，主要用途是給商店的上架系統識別使用，並不會給使用者知道。此外，在兩個作業系統中，建置號碼的規則也不太一樣。 iOS Android 格式 建議 Semantic Versioning 須為數字 規則 同版名中不能重複，不同版名間可以重複 無論版名必須往上遞增 限制 無特定格式限制 不能超過2100000000 為了管理方便，我這裡採雙系統皆取一致的版名跟版號。版名的話就依 package.json 的 version 而定；版號的話因 Android 的限制比較多，所以就以 Android 的命名規則來取版號。 版號邏輯可以根據喜好或維護方便而定。而我訂的版號規則是： 固定八位數，格式為 yymmddnn yy：年份的後兩位數 mm：月份，固定兩位數 dd：日期，固定兩位數 nn：建置序號，固定兩位數 同個日期就把建置序號從 00 往上遞增 不同日期就把建置序號歸為 00 在 fastlane 中，iOS 的版名跟版號都有內建的 action 可以讀寫；不過 Android 的部分就要另外安裝 plugin。 版名 iOS Android 讀 get_version_number get_version_name 寫 increment_version_number increment_version_name 版號 iOS Android 讀 get_build_number get_version_code 寫 increment_build_number increment_version_code 版名因為需要取得package.json，所以我們需要安裝 plugin load_json。 12345678910111213package = load_json(json_path: &quot;../package.json&quot;)curr_build_number = get_build_number().to_idatetime_number = Time.new.strftime('%Y%m%d')[2, 6].to_i * 100diff = curr_build_number - datetime_numbernew_build_number = 0;if diff &gt;= 0 # same day new_build_number = datetime_number + diff + 1else # another day new_build_number = datetime_numberendincrement_build_number( build_number: new_build_number) 打版本 tag以我的需求來說，希望每次的更版在 git 上留下紀錄。因此我會把版名加上版號組成一個完整的版本名稱，接著在打到 git tag 上。 需要使用的 action 有 add_git_tag。 123456package = load_json(json_path: &quot;../package.json&quot;)version_name = package['version']version_code = get_version_code()add_git_tag( tag: &quot;v&quot; + version_name + &quot;-&quot; + version_code) 建置安裝檔Android 中的建置階段非常簡單，不需要任何的驗證或設定，只需要知道這次要建置的是 Debug 版或是 Release 版就好。 Android12# 相當於執行 gradlew clean &amp;&amp; gradlew assembleDebuggradle(task: &quot;clean assembleDebug&quot;) iOS 的就比較麻煩，好在 fastlane 有提供介面相對友善的套件-gym。我們可以使用 build_app 這個 action 來完成建置的設定。 iOS123456789101112131415build_app( silent: true, clean: true, configuration: &quot;Release&quot;, scheme: &quot;AppName&quot;, output_name: &quot;app.ipa&quot;, export_options: { # 指定部署方式 method: &quot;enterprise&quot;, # 指定 provision profile provisioningProfiles: { &quot;app.bundle.indentifier&quot; =&gt; &quot;ProvisionProfileName&quot;, } }) 上傳至 Dropbox產生安裝檔後，我們是選擇以 OTA 方式，將安裝檔放在雲空間供測試人員下載。如何建立 OTA 的安裝機制，可以參考這篇文章。 以 Dropbox 當作雲空間的話，設定的重點有以下： 在 Dropbox Developers 建立應用，然後取得 token。要注意的地方有以下： token 的期限要設為 No expiration，不然預設 15 分後就會到期。 需要打開檔案的編輯權限 file.content.write 參考 fastlane 的這份文件，將 token 這種機敏資訊妥善管理。我這裡是使用 dotenv，好處是不用更改本機的環境變數，透過 gitignore 方式將機敏檔案過濾掉。 在專案根目錄下執行 gem install dotenv 安裝 在專案根目錄下新增 .env.secret .env.secret12DROPBOX_OAUTH_TOKEN=&quot;xxx...&quot; 在 Fastfile 中引入 dotenv 跟 剛剛建立的 .env.secret Fastfile123456fastlane_require 'dotenv'before_all do Dotenv.overload '../../.env.secret'end 安裝 fastlane-plugin-dropbox。欄位的注意事項有以下： write_mode-寫入的模式，文件上有寫比較理想的方式是update，不過還沒弄清楚 update_rev 要如何設定，所以目前測試ＯＫ的是overwrite file_path-要使用安裝檔的絕對路徑 dropbox_path-中文名稱也ＯＫ。沒有這個欄位的話預設是上傳到根目錄 access_token-以 ENV[name] 來取得剛剛在 .env.secret 建立的 token 值123456dropbox( write_mode: 'overwrite', file_path: '/Users/sss/xxx/ooo/ios/app.ipa', dropbox_path: '第一層目錄名稱/第二層目錄名稱', access_token: ENV['DROPBOX_OAUTH_TOKEN']) 通知工作群組當安裝檔建置完成、上傳到雲空間後，相關人員就可以前往更新版本了。如果團隊中有使用會話群組，像是 slack 、 google chat 等，fastlane 有提供相關的 plugin 來幫我們做到主動通知的事情。 首先安裝 fastlane-plugin-google_chatfastlane add_plugin google_chat 在會話群組的聊天室名稱，右邊有個小三角形，點選後選擇「管理 Webhook」 一開始如果沒有設定 webhook，會直接讓你輸入名稱跟圖片網址。名稱可以輸入 fastlane，之後新增其他的服務連動，會比較清楚是哪個來源打的。圖片網址可以不設，也可以取找對應的icon網址填入。 點選「儲存」後就可以產生並取得 Webhook 的連結囉！ 最後，參考作者的範例修改就ＯＫ了。 12345678910111213package = load_json(json_path: &quot;../package.json&quot;)curr_build_number = get_build_number()google_chat( imageUrl: 'https://xxx.ooo.png', webhook: 'https://chat.googleapis.com/v1/spaces/xxx/messages?key=ooo&amp;token=jjj', title: 'ZZZ App 開發版', description: 'Android Debug / iOS Enterprise 已更新，請前往下載安裝！', section1Title: 'Version', section1Description: &quot;v&quot; + package[&quot;version&quot;] + &quot;-&quot; + curr_build_number, buttonTitle: &quot;開啟下載安裝頁&quot;, buttonUrl: &quot;https://fff.com&quot;) 執行 fastlane 任務上面這些 fastlane 的任務，要怎麼串連起來呢？ 通常我們會把這些單一任務分別用 private_lane包覆起來，表示這是不能單獨執行的。接著再新增一個用 lane包覆起來的任務，工作內容就是依序執行這些私有任務。 private_lane 的寫法： 1234desc &quot;Android Debug: Build a Debug App&quot; private_lane :debug_build do gradle(task: &quot;clean assembleDebug&quot;) end 在 Android 裡的 lane Android12345678desc &quot;Android Debug: Do all jobs&quot; lane :debug_jobs do version_code version_name git_version_tag debug_build debug_upload end 在 iOS 裡的 lane iOS12345678desc &quot;iOS Enterprise: Do all jobs&quot; lane :enterprise_jobs do build_number version enterprise_archive enterprise_upload notify_chat end 為了更方便執行指令，可以新增npm指令。 有個題外話，我在切到 ios 的目錄後，執行 fastlane 的前綴有加 arch -x86_64，原因是我目前使用 Mac m1，因為硬體上的限制才需要加。如果之後在安裝什麼或執行什麼時發生意外錯誤，可以試著加加看。 123&quot;scripts&quot;: { &quot;dist-dev-app&quot;: &quot;cd android &amp;&amp; fastlane debug_jobs &amp;&amp; cd .. &amp;&amp; cd ios &amp;&amp; arch -x86_64 fastlane enterprise_jobs &amp;&amp; cd ..&quot;,} 更新 CHANGELOG.md最後，就是產出 CHANGELOG.md，並更新到 git 上囉！ 同樣我們可以為冗長的 cli 新增 npm 指令： 123&quot;scripts&quot;: { &quot;cg&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -s -r 0 &amp;&amp; git commit -am CHANGELOG.md&quot;} 結論在導入這些工具時，其實不到半天的時間就可以完成了。學習門檻來說，也不用太高，頂多只需要查詢一些 ruby 的基本語法等，算是很值得上手的工具。比較重要的是要思考任務的安排合不合理，在自動化和後續維護上是不是可以更順暢；另外在部署上架版的流程和跟開發階段的流程勢必會不太一樣。到時候有什麼新想法，再跟大家分享囉 👋","link":"/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2021041514/"},{"title":"AC 關鍵字計畫 | API 開發、測試、除錯一次到位！使用 MSW 快速上手 Mock API","text":"本篇文章已刊載在AC Blog。 什麼是 API在認識 API 以前，我們直接從生活中的例子來認識介面 (Interface)。 忙碌的午後，「小美」想要喝罐可爾必思。於是她前往公司樓下的飲料販賣機，在「操作面板上」投硬幣跟按按鈕，販賣機裡的「系統」判斷金額是否符合，以及是按下哪個飲料的對應按鈕。判斷結束後，就把一罐可爾必思推出來。最後小美從取物口拿出，大口地暢飲。 在上述例子裡，飲料販賣機的控制面板即為人機互動的「介面」，也就是等下待會要講的「API」。而小美呢，則是介面的使用者，對應到軟體開發的領域上是指 API 的使用者，也就是我們這些應用程式的開發者。 API（Application Programming Interface）的字面意思是「應用程式介面」。就像飲料販賣機的介面一樣，API 是應用程式之間一套明確定義的溝通方法和接口。使用 API 的過程中，不需要理解內部複雜的運作，只需要知道要呼叫什麼方法，傳入對應參數，就能取得想要的結果。 Web 應用程式中的 API在 Web 應用程式的開發情境下的 API 被稱為 Web API，在 Web API 作用時，客戶端（前端）和伺服器端（後端）會透過 HTTP 通訊協定來進行請求與回應。 作為前端的開發者，為了要取得存放在系統的資訊，常常會需要以 Web API 來發送請求與後端溝通。因此通常需要做的事情有以下： 閱讀 API 文件 如果是第三方開發的應用（例如 Google、Facebook），可能需要註冊、驗證等程序 撰寫有關 Web API 串接的函式 在適當時機點呼叫對應的串接函式 而後端的開發者，則是將擁有的資料庫開放給第三方使用。因此開發步驟大致會是這樣： 撰寫一個明確的 API 文件，清楚定義 API 的使用方式及格式等等。 按照文件開發一個 Web API，提供可外部呼叫的方法，用這個方式做為使用介面。 控制 API 的回傳結果，可能嗎？前端開發時，十之八九都會需要實作 API 的串接。你可能會先建立相關的函式模組，然後在元件或是狀態管理的程式碼中匯入，在適當時機點發出 API 的請求。 問題來了，如果想要測試 API 回傳不同的結果下，元件的操作邏輯是否正常；或是現在正處於雛型（Prototype）開發的階段，在後端的 Web API 還沒完成的情況下，前端要超前部署產出具體的半成品等，前端這邊是不是可以先實作好 API 串接的部分，而且還能隨意控制 API 回傳的結果呢？ 舉個簡單的例子，在 api.js 中，定義了所有跟 API 串接的函式模組，其中，isLoggedIn 函式是檢查使用者是否已登入。 api.js 1234567export async function isLoggedIn() { axios.post(&quot;/api/account/isLoggedIn&quot;) .then(response =&gt; { // ... });}// ... 在元件－ App.js 中，我們匯入isLoggedIn 函式，並且在適當時機點呼叫它，如果已經登入，執行 A，否則執行 B。 App.js 12345678910111213141516171819import { isLoggedIn } from './api';function App() { //... await function initApp() { const isLoggedIn = await isLoggedIn(); if(isLoggedIn) { // 做 A 事... } else { // 做 B 事... } } //... React.useEffect(() =&gt; { initApp(); }, []); //...} 假設不變動 App.js 中的－ 1const isLoggedIn = await isLoggedIn(); 我們有辦法由前端控制 isLoggedIn 變數是 true 還是 false，來檢查相關的條件判斷嗎？ 這個問題，當然是 YES 囉！這就是今天要講的－Mock API。 API 開發、測試、除錯一次到位－Mock API先來說文解字一下，「Mock」是從單元測試的概念延伸而來的，主要是模擬真實的物件或類別，但是省略內部複雜的行為，讓測試過程可以更專注在本身的測試重點上。 同樣地，比起透過真實的後端 server 取得資料，我們有時候會比較想要自己決定資料的樣子，甚至是定義 API 的入口點（entrypoint）和參數欄位等等，但同時又不想變動前端呼叫 API 串接的部分。可以完成以上種種行為的方式，就是 Mock API。 使用 Mock API 的理由最普遍的使用需求，應該就是希望在初期的開發階段，前端不需要等後端實作完成後才能接著進行。除了讓開發時程不用花到雙倍的時間，前後端雙方也能透過 Mock API 的過程更具體討論實作細節，達成品質與速度都能雙贏的目的 💪 除此之外，以下的場合也能應用 Mock API 來完成： 撰寫測試案例：進行元件測試或 E2E 測試時，可以撰寫各種 HTTP 狀態，或是不同回應資料時的測試案例。 開發時的除錯：藉由修改 mocking 的內容，幫助元件或頁面進行除錯。 向 MSW Say Hi！ MSW（Mock Service Worker）是一套可以實現 Mock API 的工具。最大的特色是能在網路層（Network）發出實際的請求（Request），並透過 Service Worker 攔截，回傳已經定義好的資料內容。 另外，MSW 也擁有許多優點，像是： 跟許多框架、工具都有很好的整合性，像是 React、Jest、Cypress 等。 針對主流的 API 設計－RESTful 和 GraphQL 都有良好的支援。 如果專案是以 TypeScript 開發，不須特別設定就能直接使用 TypeScript，享受強型別帶來的便利與好處。 清楚好閱讀的官方文件，並且有範例程式，讓開發者能好上手。 因此跟其他相似的工具來比較，像是 MirageJS、json-server，MSW 的下載使用量平均超過它們的兩倍，並且有成長的趨勢。這也表示相關的社群資源和討論聲量也會愈來愈豐富。 在熟悉 MSW 之前，我們先基礎認識它的底層機制－Service Worker，以及知道 RESTful 和 GraphQL 的差別。 Service WorkerService Worker 是 Web Worker 的一種。除了可以在背景執行緒中運作，不影響使用者的網頁瀏覽體驗以外，最大特色是透過 cache 的機制來打造離線體驗。我們多少會碰到一些網站提供推播通知、暫存資料或是背景中同步等功能，這要多虧有 Service Worker 的實現。 導入 Service Worker 有幾個重點步驟： 檢查瀏覽器的支援度：基本上除了IE，大部分瀏覽器在某版本之後都有陸續支援，如果需要，可以加上檢查。 123if ('serviceWorker' in navigator) { // ...} 註冊：呼叫全域方法 navigator.serviceWorker.register() 進行註冊。由於這是個 promise 函式，可以透過 then 跟 catch 來做完成後的處理。 123navigator.serviceWorker.register('/serviceWorker.js') .then(register =&gt; {}) .catch(error =&gt; {}); 安裝：註冊完後，會觸發 serviceWorker.js 中的 install 事件，執行瀏覽器的離線快取功能。 123this.addEventListener('install', function () { // ...}) 啟動：註冊完後，會觸發 serviceWorker.js 中的 active 事件，正式啟動 Service Worker。 123this.addEventListener('active', function () { // ...}) 存取請求內容：當在這個 Service Worker 的可控範圍內偵測到 HTTP 請求，會觸發 serviceWorker.js 中的 fetch 事件實作 cache 的機制。 123this.addEventListener('fetch', async function (event) { // ...} 收發訊息：觸發 serviceWorker.js 中的 message 事件，處理各種請求階段的接收與發送訊息。 123this.addEventListener('message', function(e) { // ...}); RESTful vs. GraphQLRESTful 是一種 API 的設計風格，將有語意性的詞彙加上資料參數形成特定路由（Route），並運用 HTTP 各種定義的請求方式，向後端取得資源或是修改資源。 因此 RESTful 最大的特點是，可以透過路由的結構清楚知道資料欄位跟操作方式，適合用來設計簡單或是結構較為單純的 API。 GraphQL 是由 Facebook 在 2015 年發布的 open source。透過前端定義的資料結構，告訴後端返回相同資料結構的對應資料，來避免後端設計大量的 API route ，或是返回多餘的資料欄位。 不過這種靈活性也增加了複雜性，通常會比較適合用來設計具規模或是結構比較交錯複雜的 API。 MSW 初體驗如果只是想先體驗看看，不用大費周章建立環境，可以參考 MSW 建立的範例程式，裡面有許多不同的範本專案。切到不同的專案環境後，就可以執行相關指令玩玩看囉😊 clone 範本專案。執行以下指令，或是使用 GitHub Desktop 的 Clone Repository &gt; URL 輸入以下的網址部分。 1git clone https://github.com/mswjs/examples.git 切換到 examples 目錄。 1cd examples 安裝所有依賴套件。 12yarn# or npm install 切換到特定目錄，例如：想看使用 React，加上 RESTful 的 API 設計會是什麼樣子，那麼就切換到 rest-react。 1cd examples/rest-react 執行以下指令，在本機建立 live server。 1yarn start 打開瀏覽器輸入 localhost:3001。正常的話，可以看到頁面上有個簡易表單。按 F12 觀察 console，就會出現 [MSW] Mocking enabled.的訊息，表示 MSW 已經在運作囉！ 可以把 Dev Tool 切到 Network 觀察。在表單欄位隨意輸入後送出，會發現 Network 中發出了一個 login 的請求。 再切回 Console，可以看到 MSW 有印出請求的 Request、Reponse 的詳細內容。找到程式碼來對照看看，的確 MSW 發揮了作用，以程式中定義好的資料作為 Response 的資料，magic~ 建置與導入 MSW如果想引入專案環境中，其實非常簡單，基本上安裝 msw 這個套件就可以了。 12yarn add -DW msw# or npm i msw -D 不過不少人，包括我自己是用 webpack 來打包前端程式和建立 live server。因此接下來的建置流程會再多介紹 webpack 的導入方式。 安裝 MSW 以及執行 webpack 時所需的 plugins，作為開發用的依賴套件。 12yarn add -DW msw copy-webpack-plugin workbox-webpack-plugin# or npm i msw copy-webpack-plugin workbox-webpack-plugin -D 在專案的根目錄下建立 public 的子目錄，如果已經有的話省略。 在 src 的目錄下建立 mocks 的子目錄。 在 mocks 的目錄下建立兩個檔案－ handlers.ts(js) 以及 browser.ts(js)，待會會提到更多這兩個檔案的實作部分。 在專案的根目錄下開啟終端機，執行以下指令來建立負責產生 Service Worker 的程式檔 mockServiceWorker.js。如果有興趣的話，可以從這份檔案來看 MSW 如何設計 Service Worker 的架構與各種生命週期的事件喔！ 1npx msw init public/ 在 webpack.config.js 或特定的 webpack 設定檔中，在 plugins 部分新增跟 Service Worker 相關的設定。 CopyWebpackPlugin－ 將 mockServiceWorker.js 複製到 live server 中。 WorkboxPlugin－ 建立 Service Worker。 1234567891011121314const CopyWebpackPlugin = require('copy-webpack-plugin');const WorkboxPlugin = require('workbox-webpack-plugin');module.exports = { // ... plugins: [ //... new CopyWebpackPlugin([ { from: path.resolve(__dirname, './public', 'mockServiceWorker.js'), to: 'mockServiceWorker.js' }, ]), new WorkboxPlugin.GenerateSW(), ]} 在 index.html 偵測當前瀏覽器有無支援 Service Worker，有的話就以 mockServiceWorker.js 來註冊 Service Worker。 123456789&lt;script&gt; // Check that service workers are supported if ('serviceWorker' in navigator) { // Use the window load event to keep the page load performant window.addEventListener('load', () =&gt; { navigator.serviceWorker.register('/mockServiceWorker.js'); }); }&lt;/script&gt; 如果按照以上步驟做完的話，目錄結構應該會長這樣－ 123456789-- MyProject/ -- public/ -- mockServiceWorker.js -- src/ -- mocks/ -- browser.ts(js) -- handlers.ts(js) -- index.html -- webpack.config.js 快速上手 MSWhandlers.ts(js) 是負責撰寫 mock API 的實作細節。通常會建立一個陣列變數－handlers 來存放各個 API 串接的實作。 1export const handlers = []; 舉上面範例程式的 login 請求作為例子，分別看看 RESTful 跟 GraphQL 這兩種 API 設計模式，MSW 會如何實作。 RESTful從 msw 匯入 rest。rest 提供了各種模擬 HTTP 的請求方式實作－ rest.get()：對應 GET 請求，取得資源。 rest.post()：對應 POST 請求，提交指定資源的實體。 rest.put()：對應 PUT 請求，上傳或取代指定的資源。 rest.patch()：對應 PATCH 請求，指定資源的部份修改。 rest.delete()：對應 DELETE 請求，刪除指定資源。 rest.options()：對應 OPTIONS 請求，查詢 server 支援的 HTTP 請求方式。 這些方法需要固定傳入兩個參數－ entrypoint－API的路徑，可以 /:someData 的方式以路徑傳入資料參數。 resolver function－請求完成後的 resolve 函式。有三個參數可以操作，分別是－ req：req.body 的物件可以取得 Request body 中的資料參數。 res：執行 res() 來回覆請求。 ctx：執行 ctx.json({...}) 組合回傳的資料，定義想要的格式和內容。 12345678910111213141516import { rest } from 'msw'export const handlers = [ rest.post('/login/:someData', (req, res, ctx) =&gt; { const { username } = req.body return res( ctx.json({ id: 'f79e82e8-c34a-4dc7-a49e-9fadc0979fda', username, firstName: 'John', lastName: 'Maverick', }) ) }),] GraphQL從 msw 匯入 graphql。graphql 實作了兩種操作方式： graphql.query()：對應 GraphQL 的 Query 來完成資源的查詢。 graphql.mutation()：對應 GraphQL 的 Mutation 來完成資源新增、刪除、修改等會產生副作用的操作。 這些方法需要固定傳入兩個參數： name－已經定義好的 Query 或 Mutation 名稱。 resolver function－請求完成後的 resolve 函式。有三個參數可以操作，分別是－ req：req.variables 的物件可以取得 Request 中的資料參數。 res：執行 res() 來回覆請求。 ctx：執行 ctx.data({...}) 組合回傳的資料，根據定義好的欄位格式，設計想要的內容。 12345678910111213141516171819import { graphql } from 'msw'export const handlers = [ // Capture a &quot;Login&quot; mutation graphql.mutation('Login', (req, res, ctx) =&gt; { const { username } = req.variables return res( ctx.data({ user: { username, id: 'f79e82e8-c34a-4dc7-a49e-9fadc0979fda', firstName: 'John', lastName: 'Maverick', }, }) ) }),] 當我們寫好 handlers 後，在 browser.ts(js) 中就可以新增負責初始化 MSW 的變數，並且傳入 handlers 作為初始化的參數， 讓 MSW 知道遇到哪些請求後要執行 mock API 的動作。 12345import { setupWorker } from 'msw';import { handlers } from './handlers'// This configures a Service Worker with the given request handlers.export const worker = setupWorker(...handlers); 通常我們會在本機的開發環境，或是執行測試時，才會希望啟動 MSW。因此我們可以在主程式的進入點加上環境的條件判斷。 12345import { worker } from './mocks/browser';if (isTesting || process.env.NODE_ENV === 'development') { worker.start();} 小結針對不同專案找出最適合的 API 設計，以及讓前端可以在面對各種資料情況時，都能提供良好的介面與瀏覽體驗。這些事情都可以透過 Mock API 的過程中實現。希望透過今天的介紹，讓大家對於 Mock API 有更深的了解，並且感受 MSW 擁有的魅力與好處🥳 Reference API是什麼？認識 Web API、HTTP 和 JSON 資料交換格式 Service Worker 什麼是REST? 認識 RESTful API 路由語義化設計風格 GraphQL wiki","link":"/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2021081414/"},{"title":"ModernWeb&#39;21 | 系列心得文(I) | 10 場 F2E 會有興趣的議程","text":"前言為期 13 天，多達 40 場以上的議程，ModernWeb’21 終於在今天圓滿落幕了! 因為疫情的關係，一直以來都是實體方式進行的 ModernWeb，從去年開始轉為線上的形式舉行。雖然比較難感受到大家齊聚一堂，熱情參與的盛況。不過經過這幾天的體驗下來，其實線上方式帶來許多的好處，像是－ 實體方式通常會多軌進行，如果有兩場以上有興趣的議程，只能做割捨；不過線上方式是單軌，只需要看有興趣的議程是哪幾場，然後記住直播時程就好。 由於內容是採預錄，所以直播過程中有些講者也會上線參與。如果觀眾有什麼問題，或是講者有什麼補充的話，就能即時地問答互動。 由於可以匿名參與，觀眾可以盡情地在聊天室中可以更多互動，甚至有新的收穫。 FREE! FREE! FREE! 很重要所以要說三次，雖然知識無價，不過現實面來說可以省掉幾千元的門票還有通勤成本，對於我們這種又窮又忙的小資族真的是天降甘霖🥺 這裡也特別感謝主辦單位的佛心! 接下來我想趁記憶鮮明的時候，整理出 10 場 F2E 可能會有興趣的議程，以及 5 場個人印象蠻深刻的議程分享給大家，有興趣的話可以接著看下去。 議程整理從 React 到 React Native 到 React Native Web 開發與設計須知 講者: Caesar 大大 關鍵字: React Native, Mobile Web, Screen, React Navigation, ScrollView, dp(font size), ListView 心得: 由於今年開始碰 mobile app，所以對 React Native 的主題算是最有興趣的。講者列舉了幾種 UI 在 Web 和 mobile 的不同，以及在 mobile 開發上的最佳實現，收穫良多! 依照古法、純手工打造的視訊聊天網站，不純免錢！ 講者: 高見龍 大大 關鍵字: Websocket, WebRTC, Signal Server, SDP, NAT, STUN, MediaDevices, Peer.js 心得: 只能說這個議程有滿滿的技術含量，但是講者又能用一些平易近人的比喻來解釋，以及最後的 DEMO，不靠任何 infra 就能簡單建立起視訊的聊天室，算是開眼界了，讚讚! 當原子設計遇上網頁建構器 講者: Kim 大大 關鍵字: 原子設計, Design System, 網頁建構器, UGC, 模組 心得: 之前就有瞄過相關的文章，當下覺得太神啦! 這次議程中，Kim 大大用衣櫃這個例子很清楚解釋原子設計，然後怎麼應用到網頁建構器中，讓我有新的收穫。 pxcode 前端工具的開發經驗分享 講者: Chris Chang 大大 關鍵字: pxcode, Posize, Fusion Flex, Resizing Contraints 心得: 聽完之後，只能說我之前太小看排版這件事。其實要做到完美的響應式設計真的沒那麼簡單，很多時候只是 designer 沒在跟你計較而已QQ 講者開源的 Posize 和 Fusion Flex 是我會再認真著墨的地方。如果可以的話，也會想試用 pxcode 看看! Svelte - 如何在前端框架中脫穎而出 講者: 愷開 大大 關鍵字: Svelte, Reactivity, directive(描述符), 事先編譯 心得: 聽完之後除了可以了解 Svelte 想解決的問題和優點之外，我更想了解簡報是用什麼工具做的XD 希望有哪位善心人士可以跟我說，不然我就要鼓起勇氣直接詢問本人啦! 透過 Headless CMS 讓前端與行銷團隊高效合作 講者: Roy 大大 關鍵字: Headless CMS, directus, strapi 心得: 由於目前正在進行 wordpress 相關的專案，加上之前有負責過有關 CMS 的專案，所以對這個議程還蠻有興趣的。聽完之後也收穫滿滿，之後應該會玩玩看 Roy 大大推薦的 directus，以及在聊天室中有提到的 strapi。 JavaScript 概念三明治：基礎觀念、語法原理一次帶走！ 講者: 木景 大大 關鍵字: 強制轉型, 物件型別, 原始型別, 執⾏環境, 執⾏堆疊, 非同步, Associativity(相依性), Event Queue 心得: 看過他寫的書的話，就可以知道他對知識的整理與視覺化非常厲害，很多用文字很難說清楚的概念，像是強制轉型、相依性等，都會透過循序漸進，簡單明瞭的圖示和程式碼呈現。這點也是我持續學習的地方。 誰說 SPA 無法做 SEO？加強 React SEO 的 N 種方式 講者: KK 大大 關鍵字: SPA, SEO, CSR, SSR, React, Web Rendering, FID(首次輸入延遲時間), Hybrid, next.js, gatsby, Pre-render, react-helmet, prerender.io , Pre-build 心得: 個人覺得 KK 大大的演講過程中很順暢，內容雖然簡潔，不過還是可以感受到滿滿的技術量。就算沒做過 SEO 的經驗，聽完之後也會對於之後實作方向相當明確。給推! 中台雲原生之 Micro Frontends 講者: 國泰世華銀行 關鍵字: Micro Frontends, single-spa 心得: 雖然前面在講銀行的系統架構的時候不是很懂，不過中後段的講解就還蠻淺顯易懂的，除了有講到Micro Frontends 跟 Monolithic Frontends 的不同處(業務邏輯 vs 數據邏輯)，還有Micro Frontends的優點以外，後面也有帶到用 single-spa 的 DEMO。以我來說的話，應該會觀察公司的後續發展，視情況列入想研究的主題之一。 API 開發、測試、除錯一次到位！使用 MSW 深入淺出 Mock API 講者: Yuri 關鍵字: API, Mock API, Service Worker, MSW, JavaScript 心得: YA! 請容我光明正大地偷渡自己的議程😉 還沒看過或是想再看一次的話，可以從 ModernWeb 官網下載簡報，或是直接去看文字版喔~ 小結不管是參加研討會，或是加入技術社群，看到一個嶄新或是陌生的技術出現在眼前，雖然當下覺得這東西好讚!學起來我就超強之類的。但下意識其實都有點恐慌，畢竟 Web 開發的領域變化的太快，加上有這麼多的強者不斷地造出強而有力的輪子出來，自己會有種不進則退、如履薄冰的緊張感。 如果跟我有同樣感受的話，建議首先要做的，就是找出適合自己的學習節奏，還有安排優先順序。舉上面這 10 場議程來說，假設對這些內容都不熟，是不是就要強迫自己每項都要學到透徹，才能算是一位稱職的 F2E 呢? 其實不是，首先要了解 F2E 的必修內容有哪些。例如: 如果你聽木景大大分享 JavaScript 的概念時，發現有一知半解的情況時，就會知道基礎不夠扎實。如果對 JavaScript 的基礎認識不夠，在之後吸收新技術時就會比較難融會貫通，對實務開發上就難有真正的加分。因此你該優先做的，就是看完木景大大出的書，以及 Yuri 即將要出的ECMAScript關鍵30天。 之後可以列出近期自己在實務開發上遇到的問題，或是想導入的解決方案。以我來說的話，可能有以下幾點－ 在公司專案和 side project 上都會使用 React Native，那麼由 Caesar 大大分享的開發與設計須知對我來說就很有用，可以針對我還陌生的部分加以了解。 公司一直很想發展 CMS ，不過目前為止都沒有成功的解決方案，那麼由 Roy 大大分享的 Headless CMS 對我來說就值得深入研究並且嘗試。 藉由這樣的列表整理，並且安排學習計畫到開發日常中，就能更加地學以致用。 最後趁工作空檔時間，並且心有餘力的話，再來認識有興趣的主題。這時候的學習節奏就不用太快，也不用強迫自己一定要導入實務中。像是我對 Svelte 還蠻有興趣的，之後可能就會找時間了解它的語法結構和應用場景，然後再試著動手做出簡單的 project 出來，甚至跟同事進行分享等等。 雖然我也還在練習，不過參加研討會的目的並不是要包山包海地通學，而是一種能多開自己眼界的方式，讓自己可以有更多的選擇，共勉之😊","link":"/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2021102816/"},{"title":"ModernWeb&#39;21 | 系列心得文(II) | 5 場讓我印象深刻的議程","text":"前言接續上一篇，今天是整理了 5 場不限任何領域，純粹是自己頗有記憶點的議程。 議程整理八個沒人告訴你的網頁自動化測試挑戰 講者: Melo 大大 關鍵字: SideeX, Selenium IDE, code less, ⾃動化測試, 跨瀏覽器, RWD, 視覺測試, 影像辨識 心得: 講者本身就是在 SideeX 從事測試工程師。所以他整理有關自動化測試的眉角都是實務中很常遇到的問題。也是因為這場議程，讓我認識到 SideeX 這個神奇的 code less 測試工具。 聽完這場後其實有點感慨。之前跟同事閒聊時，知道公司的大大雖然很照顧員工的職涯規劃，不過他對於 QA 的認知似乎就是發展性很有限，並不想要擴編相關職位，也沒有要投入資源。不過還是非常非常希望敝公司可以多花點資源培育 QA ，至少能夠使用這種 code less 工具，還有建立 Web 的基礎知識。不然產品線愈來愈多，QA 也就一雙手一雙眼睛，開發者也不見得有時間可以寫充足的測試。等到之後有類似的產品出現，但是穩定性跟品質都被屌打時，還能說 QA 不重要嗎? 希望年底評鑑寫的這項建議可以被看見，培養出厲害的 QA 吧! 做 A/B Testing 好難，你有試過 Google Optimize 嗎？ 講者: Kyo 大大 關鍵字: A/B Testing, Google Optimize, 轉換率, 滯留率, GTM, 個人化體驗 心得: 雖然有聽過 A/B Testing，不過我太孤陋寡聞，Google Optimize 還是第一次聽到QQ 看到講者拿 ModernWeb 官網直接 DEMO Google Optimize 實現 A/B Testing 的作法，覺得很是神奇。有些時候在跟專案成員討論哪種 UI 呈現方式比較好時，大家都是憑空想像有各自的想法。比較理想的方式應該還是在產品開發的週期中導入 A/B Testing，讓數據說話。 LINE 只能用來聊天？ 分享 LINE 台灣如何用官方帳號打造內部員工系統 講者: Evan 大大 關鍵字: OAuth2, OpenID, SSO, PKCE, LINE Clova 心得: 雖然講者沒提供簡報，不過針對比較核心的登入機制，講者已經有寫了文字版，個人覺得因為議程時間有限，所以文章內容會比較清楚。開發經驗中雖然有碰過 OAuth2 跟第三方登入，不過其實只是懂表面，程式寫完之後也沒有再深入研究。這場主要講 OAuth2 存在的安全問題，還有介紹LINE 的登入機制導入了更安全的 PKCE。最後用截圖分享 LINE 怎麼透過官方帳號建立內部員工系統，透過 Clova 打造更直覺的查詢服務。 Building Chatbots with Low-Code / No-Code 講者: Ko Ko 大大 關鍵字: Chatbots, Low Code, No Code, Dialogflow, Microsoft Bot Framework Composer, Microsoft Power Virtual Agents, Azure 心得: 這場很有記憶點的地方，老實說很大一部份是因為講者的聲音很好聽😆 講的內容也沒什麼負擔，基本上透過介面操作就完成一個簡單的聊天機器人，然後部署到 Azure 上。我覺得對於想要替網站增加一些有趣的互動功能，Chatbots 會是個蠻好的方向。 讓 Python 爬蟲也能讀得懂「滑動驗證碼」 講者: 維元 大大 關鍵字: 網頁驗證碼, Slider Captcha(滑動驗證碼), Python, OpenCV, Selenium, 爬蟲 心得: 第一次在 b 站接觸到滑動驗證碼的時候，覺得這個很是神奇。而且印象中圖片很可愛，加上那種滑動缺塊就可以完成拼圖的趣味感，體驗上來說還蠻不錯的。不過這個議程內容並不是教大家怎麼做這個驗證碼，而是怎麼教基礎的圖像識別概念，然後 DEMO 讓 Python 爬蟲透過 OpenCV 和 Selenium 來找出缺塊並且模擬滑動行為，這個議程內容也有文字版，如果有遇到這種問題的人，應該會覺得非常有幫助! 另外前陣子因為 JSDC 認識了講者，在這裡也很感謝他邀請我舉行其中一場的前導活動，也算是幫我成就解鎖😊 小結由於今年碰的專案主要是 mobile，所以比較少機會接觸到其他的技術領域。經過這幾天下來，除了可以知道一些技術上的趨勢和眉角，也觀摩到厲害的講者是如何把滿滿技術含量的內容順暢地表達，而且還能用平易近人的方式教授，這也是除了技術能力以外我想努力的地方。","link":"/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2021102916/"},{"title":"JSDC 2021 前導活動 | ECMAScript 關鍵 30 天 | Are you ready? ES2022!","text":"前言ECMAScript 原本是不定期地釋出版本，但因應提案的踴躍和開發需求的迫切，所以從 ES2015 後就改為一年一修。也就是說每年都會有新的語法標準出現，讓開發者可以使用更簡潔彈性的語法撰寫，或是實現更強大的功能。 接下來整理預計會在 ES2022 釋出的提案，以簡單的說明加上清楚的程式範例，快速了解起手式💪 ECMAScript 提案五階段一個想法出來到納入提案，接著成為修訂標準，通常會經歷以下 5 個階段－ Stage 說明 0 由 TC－39 的成員或其他人提出後，委員會沒有否決的討論或想法 1 正式成為提案，需有具體語法和描述，部分會有Polyfill的實現 2 可能有相關的運作環境或編譯器提供實驗性的功能實現 3 成為候選提案，部分運作環境或編譯器提供原生支援 4 通過至少兩個驗收測試，等待下版釋出時成為修訂內容 今天要講的語法，都是已經進到 finished，也就是 Stage 4 階段的提案。有興趣的話，可以前往 TC－39 的 GitHub 看相關整理。有趣的是，在這裡不僅可以看到語法的開發動機和具體描述，也能看到在提案推進的過程中，開發者與委員們的討論紀錄，可以更進一步地了解標準推出的始末。 正規表達式 先簡單複習一下。正規表達式主要有以下三種組成－ 以指定的文字加上特殊字元組成匹配的句法。 由兩個雙斜線（/）包覆匹配的句法。 後面可以選擇性地加上一個或多個旗標，設定全域的查找規則。 其中旗標的部分，一個 RegExp 物件會針對旗標提供實體屬性來查詢。透過取得屬性值，就可以知道這個正規表達式有沒有設定對應的旗標。 Stage 對應屬性 說明 d hasIndices 回傳每個匹配內容的起始&amp;下次要開始檢索的索引陣列([startIndex, endIndex+1]) 有加上 d 旗標的正規表達式，在執行匹配相關的操作，例如 exec 時，可以多回傳一個 indices 屬性。這個屬性會包含匹配內容的起始索引，以及結束索引加 1，也就是視為下次要開始檢索的索引。 目前最新版本的 Chrome 還有Node.js中可以運作，有興趣的話可以嘗試看看。 12345678910111213141516const myRegexp = /\\w*.o\\w+/dgi; // 找出中間有 o 的單字const target = 'Born to make history';let currResult;while ((currResult = myRegexp.exec(target)) !== null) { console.log('這次的符合內容: ', currResult[0]); console.log('Matched Indices: ', currResult.indices[0]); console.log('---');}// 這次的符合內容: Born// Matched Indices: (2) [0, 4]// ---// 這次的符合內容: history// Matched Indices: (2) [13, 20]// --- 具有索引的標準內建物件常見的這類物件有字串跟陣列。那麼在 ES2022 推出了什麼相關語法呢? indexable.at(index)用途跟使用字面值取得元素的方式類似，透過索引的傳入來獲得元素。不過索引值在負整數跟浮點數時，跟字面值的回傳結果會不一樣。可以看一嚇得比較表－ 取得元素的方式 負整數 浮點數 indexable[index] undefined undefined indexable.at(index) 後面從 -1 開始算 無條件捨去後，再由正負數決定查找方向 目前最新版本的 Chrome 可以運作，有興趣的話可以嘗試看看。 1234const myArray = [0, 1, 2, 3];console.log(myArray[-2], myArray.at(-2)); // undefined 2console.log(myArray[1.6], myArray.at(1.6)); // undefined 1console.log(myArray[-3.2], myArray.at(-3.2)); // undefined 1 物件Object.hasOwn(target, propName)用來檢查目標物件有沒有屬性。那跟目前習慣使用的 hasOwnProperty 有什麼不一樣呢? 假設以 Object.create(null) 建立了空物件，然後新增一些屬性後，我們想檢查這個物件有沒有特定屬性。可是物件的原型指向了 null，所以就無法使用實體方法 hasOwnProperty，除非要直接呼叫 Object.prototype.hasOwnProperty 加上 call 方法來達到這個目的。不過這樣的寫法太冗長了。因此 ES2022 就在 Object 底下新增這個靜態方法，成為語法糖。 目前最新版本的 Chrome 可以運作，有興趣的話可以嘗試看看。 12345// beforeconst hasNameProp = Object.prototype.hasOwnProperty.call(myObject, 'name');// afterconst hasNameProp = Object.hasOwn(myObject, 'name'); 類別類別的相關語法在 ES2022 中占了蠻大一部分的內容。其中可以把這些修訂分類為－ 擴充靜態關鍵字（static）的使用 正式支援私有（private）的機制 靜態方法與成員（Static methods and fields）在 ES2015 時提出的 static 關鍵字，只能做為公開靜態方法的前綴字。不過在 ES2022 後，static 關鍵字的應用範圍更廣泛了。無論是屬性或方法，公開或私有，只要在名稱前加上前綴字，就能表示為靜態。 目前最新版本的 Chrome 可以運作，有興趣的話可以嘗試看看。 123456789101112131415class Inbody { static #secretNumber = 1.2; // ES2022: 私有靜態成員 static brand = 'My Inbody'; // ES2022: 公開靜態成員 // ES2022: 私有靜態方法 static #getPBF(weight, fat) { return ((fat * Person.#secretNumber) / weight) * 100; } // ES2015: 公開靜態方法 static getBMI(weight, height) { return weight / Math.pow(height / 100, 2); }}Inbody.country = 'Taiwan'; // ES2015: 公開靜態成員 靜態初始化區塊（Static initialization blocks）類別初始化時，有些靜態成員需要透過流程控制設定初始值的話，通常只能在類別建立後，把相關的初始流程放在之後。在程式的語意上會像是兩個獨立的區塊拼在一起，規模越複雜的話，就會降低維護性。 12345678910class APILibrary { static configs;}try { const fetchedConfigs = await fetchConfigs(); APILibrary.configs = { ...fetchedConfigs, tag: 1 };} catch (error) { APILibrary.configs = { root: 'myroot/api', tag: 2 };} ES2022後，類別中只要使用 static 關鍵字加上大括號（{ }），就能包覆靜態成員的初始流程。這樣做還有個好處是，流程中需要存取類別的私有成員時，可以直接取用，而不用再撰寫額外存取器方法來封裝，寫法上算是優雅很多。 123456789101112class APILibrary { static configs; static #defaultRoot = 'myroot/api'; static { try { const fetchedConfigs = await fetchConfigs(); APILibrary.configs = { ...fetchedConfigs, tag: 1 }; } catch (error) { APILibrary.configs = { root: APILibrary.#defaultRoot, tag: 2 }; } }} 定義私有方法與成員（Private methods and fields）成為私有成員，表示只有內部可以使用，外部如果嘗試存取或呼叫的話，就會回傳 undefined 或錯誤提示。這樣做可以保護成員不會被外部任意修改，或設定只有內部可以操作的方法等。 在 ES2022 後，正式把 # 作為私有成員的前綴字。像是上面的範例程式－static #defaultRoot = 'myroot/api';，defaultRoot 屬性就是一種私有屬性。 需要注意的是，不只是宣告，在呼叫方法或存取屬性時也需要冠上這個前綴字。更多有關私有方法與成員的範例程式與說明，可以參考我即將上市的書－ECMAScript關鍵30天。 頂層的 awaitawait 跟 async 的語法是非同步處理的語法糖。只要函式中有 await 的關鍵字出現，就一定要在該函式名稱的前面加 async 的前綴字。在 ES2022 後，可以允許在需要非同步的地方加上 await 就好，不需使用async函式封裝，提升了撰寫非同步的彈性與簡潔性。 123456789// case 1import { fetchAppConfig } from '../APILibrary';const appConfig = await fetchAppConfig();// case 2const menuData = fetch('api/config/menu.json').then((response) =&gt; response.json());export default await menuData; Babel如果有在專案中使用 Babel，並且設定 @babel/preset-env 這個 preset 的話，就可以試試看目前有支援的轉換語法，像是頂層 await、類別的靜態初始化區塊等。 TypeScript如果專案是以 TypeScript 開發，在目前的 beta 版可以透過 tsconfig.json 的 module 設定來支援頂層 await。 小結這篇文章的內容，主要是擷取自我即將上市的書。如果有興趣的話，也歡迎在 11/12 後去天瓏翻翻看，或是在博客來等網站翻一下試閱頁。有對到你的電波的話，歡迎把它帶回家喔😆 這篇內容也有影片版可以觀看。在這裡也謝謝 JSDC 的邀請，讓我有了直播技術分享的初體驗。另外 JSDC 當天的議程內容真的很充實，受益良多。有時間的話，會再陸續整理相關心得。 參考連結 TC-39 GitHub &gt; Finished Proposals Proposals included in the incoming ECMAScript 2022 standard for JavaScript Babel Plugin List Announcing TypeScript 4.5 Beta","link":"/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2021110111/"},{"title":"WordPress | 架在 IIS 的踩雷紀錄 | Give Me Pretty Permalinks!","text":"前言最近公司的工作上收到一個需求，希望把目前放在 S3 上的 WordPress 站台搬回來，並且改用 Windows Server 來 host。雖然不是第一次碰 WordPress，但是距離上一次看到他也應該也是 7、8 年以上了😅 加上我對站台建置相關的經驗很少，所以每個操作環節都還蠻小心的，很怕一個改動機器就爆了XD 之前有用過 XAMPP 等套裝軟體，一次就可以 ready 好所有環境。不過因為彈性上的考量，所以就手動從零開始建置相關的環境。雖然過程中有遇到一些小問題，不過大約不到半天的時間就可以找到相關資源解決了。步驟大概是這樣－ 啟用 IIS FastCGI 來 host php 應用程式 下載最新版的 php 修改 php.ini 設定檔 在 IIS 上新增 php 的應用程式集區 安裝 MySQL 與設定帳號 下載最新版的 WordPress 在 wp-config.php 新增 DB 相關設定 在 IIS 上設定 WordPress 站台，新增 web.config 使用 UpdraftPlus 還原備份的 WordPress 跟 DB 從 DB 修正相關的路徑連結 問題還原完成後，原本覺得弄得差不多了，但是發現幾乎所有文章和選單點進去後，都會出現內部 404 的頁面。奇怪的是如果永久連結為預設，就能連到正確的頁面。不過因為 SEO 的關係，連結格式需要是文章名稱組成。所以大概花了一個禮拜的時間找有關 permalinks(永久連結) 的相關文章。 雖然已經照大部分的文章提供的解法實作，不過還是沒辦法解決。情急之下，差一點就要開啟另外一個坑踏入nginx。就在差點放棄時，剛好看到一篇 stackoverflow 的文章，終於解決這個難題。 不過這篇文章如果只是單純下「pretty permalinks」、「IIS」、「not found」等關鍵字，其實很難找到。也因此在這裡記錄下來，分享給有需要的人。 解決安裝 URL Rewrite ModuleWindows Server 預設沒有這個模組，必須從官網或是透過 Web Platform Installer 來下載安裝。有了 URL Rewrite Module，才可以在 web.config 加入相關的 rewrite 設定 後台設定永久連結在管理後台頁，點選「設定」，然後再點選「永久連結」，就可以選擇偏好的連結格式。確定後點選「儲存設定」。 檢查 web.config通常設定完永久連結後，wordpress 會自動更新 web.config，將rewrite 設定加進去。相關程式應該會長這樣－ 1234567891011&lt;rewrite&gt; &lt;rules&gt; &lt;rule name=&quot;WordPress rule&quot; patternSyntax=&quot;Wildcard&quot;&gt; &lt;match url=&quot;*&quot;/&gt; &lt;conditions&gt; &lt;add input=&quot;{REQUEST_FILENAME}&quot; matchType=&quot;IsFile&quot; negate=&quot;true&quot;/&gt; &lt;add input=&quot;{REQUEST_FILENAME}&quot; matchType=&quot;IsDirectory&quot; negate=&quot;true&quot;/&gt; &lt;/conditions&gt; &lt;action type=&quot;Rewrite&quot; url=&quot;index.php&quot;/&gt; &lt;/rule&gt;&lt;/rules&gt;&lt;/rewrite&gt; 擴充 wp-config.php這裡是重點!! 因為其實前面幾個步驟還蠻快就可以完成。不過這個步驟是參考到這篇文章才能知道怎麼做。原文標題是Arabic url is not working in WordPress on Windows IIS Server。完全沒提到 permalink，所以這篇在搜尋結果上被埋在超級隱密的XD 最主要的問題原因是，IIS的 URL Rewrite 並沒有辦法認識多國語言的連結。所以需要在wp-config.php的最後面加上一段－ 123if ( isset($_SERVER['UNENCODED_URL']) ) { $_SERVER['REQUEST_URI'] = $_SERVER['UNENCODED_URL'];} 小結從這個經驗來看，我學到了幾件事－ 在搜尋引擎上找問題，試著先想出所有可能的關鍵字，然後用不同的排列組合下去找。 在搜尋結果頁面，像是 stackoverflow 這種網站，通常一個搜尋結果底下還有相關的文章連結，請不要放過他們，一個一個點進去看。 尋找問題要有耐心。如果開始覺得不耐煩了，就先全部關掉，明天再來。 參考資源 Enabling Pretty Permalinks in WordPress Arabic url is not working in WordPress on Windows IIS Server","link":"/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2021111210/"},{"title":"我的第一本書 | &lt;ECMAScript關鍵30天&gt; 心路歷程 | 出版的眉角分享","text":"心路歷程今年解鎖了一項從來沒想過的成就，就是我成為作家出書了！ 一切要從幾年前說起。那時候看到一位朋友在 iT 鐵人賽拿了優選，除了知道有這個比賽以外，自己也想挑戰看看。寫30天的文章來強迫自己學習技術，雖然有點辛苦，但應該會是件蠻有成就的事，而且可以探索寫程式以外的體驗，嘗試其他的可能性。於是前兩年就有持續地報名參加。 不過去年是個蠻特別的一年。記得從年中開始，就陸續給自己找了不少事做，像是心血來潮報名另一個比賽，還有腦衝在台南買房子🤣。原本想說鐵人賽就跟之前一樣，報名一個主題就好。但是在發想主題的時候，一時的腦袋短路跟自以為時間管理大師XD，一口氣報名了三個主題，一個是新書延伸的主題以外，另外兩個分別是－ 前端工程師不能不知道的生產力工具 投資小白的煉金之旅 - XScript快速入門 記得 9 月的每一天，工作以外不是忙新家的事，就是趕著每天的死線寫文章。那時候只想著能夠完賽就很厲害了。很慶幸最後不但順利完賽(雖然有幾篇真的趕不及就先上大綱XD)，而且還有主題獲得佳作，當下真的是超超超開心！ 決定跟編輯自薦前，其實經過了不少的自我懷疑和猶豫。不過回過神後就已經加了編輯的 LINE ，然後在寫出書計畫了🤣。在埋頭寫書的這半年，完全可以體驗到寫作過程中產生的煩躁、無助、詞窮、鬼打牆、校稿時的不耐煩、每次跟編輯說要 delay 的罪惡感、時程壓力等等，甚至有幾次萌生想放棄的念頭。 最後身體還出點小狀況。因為久坐加沒注意多喝水，就在交稿的前幾天血尿發燒，半夜還跑去掛急診。生活中也有些插曲，有段時間必須要幫忙張羅家裡，沒有辦法付出太多心力在書上。不過默默地，我也就走到現在了，也很開心終於完成了這項創舉😊 出書以外的新體驗寫完書後，雖然會有種終於解脫的舒適感，不過並不代表就這樣結束。寫書的目的之一，就是希望大家手上都能擁有自己寫的那本書。因此不只要行銷書，也要行銷自己，建立專業形象。雖然我不是那麼地擅長，但是到目前為止的這些嘗試，都是全新的體驗和樂趣，算是寫書以外的新收獲吧! 目前做的嘗試有－ 主動參與技術社群: 今年中加入了 ALPHACamp 的 TA 社群，除了可以跟學生教學相長，也有蠻豐富的技術資源，像是不定期的講座和技術分享等。 投稿 conference 的議程: 在 ModernWeb’21 和 JSDC 都獲得新鮮的講者體驗。 經營 SNS 與部落格: 去年開始自架部落格和經營 FB ，除了可以做知識管理，集中文章的產出，也可以熟悉架設部落格或的FB的操作眉角。 給即將踏上這條路的你去年的頒獎典禮上，&lt;IoT沒那麼難！新手用JavaScript入門做自己的玩具！&gt;的作者－17有分享一些技巧和需要注意的地方。對第一次寫書的我給了不少幫助。經過這次的體驗，我也統整編輯給的修改建議，以及一些在出版上的眉角。如果你也準備踏上這條路，希望能給你點幫助。 圖片 為了方便排版人員進行，圖片需要獨立存在一個目錄下，並且按照章節分別存放。 程式碼也是以插入圖片的方式建立的話，也要將程式碼截圖存入，並在章節目錄底下區別一般圖檔跟程式碼截圖。 圖檔名稱是以&lt;章節-編號&gt;的格式儲存。另外，如果。需要注意的是，程式碼截圖的編號是跟一般圖檔的編號是分開的，而且名稱前面要再加「程」。 在文檔中，一般圖檔的下方要註記程這樣的格式－「圖」+ 檔案名稱 + 空格 + 圖檔說明文字。程式碼截圖的話只要把檔案名稱括號起來，顏色改成紅色即可。 如果在製圖的時候需要有比較精緻的圖示或素材，一定要找免費商用的圖片來源，或是直接買授權過的圖示庫。 表格 表格名稱是以&lt;章節-編號&gt;的格式儲存。 在文檔中，表格的上方要註記程這樣的格式－「表」+ 標格名稱 + 空格 + 表格說明文字。在內文銜接到表格的最後一段文字，需要註明表格的參考處。 如果表格中有欄位是空的，則要填上文字「無」。不過這應該可以跟編輯討論是否需要加。 程式碼程式碼的截圖我是用Carbon產出的。可以一開始在設定中先調整自己的視覺偏好，然後匯出成一個設定檔存在書稿的目錄中。如果瀏覽器cache被清除的話，就能匯入設定，保持圖片呈現的一致。 程式碼內文我會在重點語法的部分上粗體，然後在第一行 comment 對應的程式檔名。由於這件事情我是在很後面才想要這麼做。所以等於是全部的程式碼截圖都要重新製作。因此也建議在一開始就先想好要怎麼呈現程式碼的內文。 內文格式以博碩來說的話，只能接受 word 檔。另外排版人員會決定具體的標題和內文的大小、字體或間距等，又或著是延伸重點的版面呈現。如果沒有特別別要求的話，其實不用花太多時間在自訂樣式上，使用 word 預設的標題級距和內文設定就可以囉! 最後有關於上面提到的圖表跟程式碼等等，建議可以初稿完成 8.9 成，基本上不會再有相關的異動的時候，再來處理就好。不然修改的過程中，很容易需要重新編號和變動檔案，這也是件很傷心費神的事，常常會頭暈眼花標錯😵 推薦序建議可以盡早決定可以幫忙寫推薦序的人選。以編輯的建議的話，盡量是請知名度高，或是在技術社群上有影響力的人幫忙寫。另外如果跟推薦人不熟的話，需要先準備好自己的背景介紹(我是直接上繳履歷XD)、書籍的文案整理，還有至少寫了 2/3 的書稿。另外也可以再多找一至兩位推薦人幫你寫推薦序，只不過要事先跟你的編輯討論喔。 時程上的話，最晚是在最後一校前把推薦序給編輯。如果怕推薦人太忙，導致時程會拖延的話，可以把編輯說的時程，再早個兩三個禮拜跟推薦人說。這樣時程上比較充裕。 文案通常交完初稿後，編輯會再跟你說要準備文案和作者介紹。這些會變成封面封底的文案內容，在銷售網站上的介紹也會從文案截取。所以需要花點時間構思一下。像是－ 書名: 可以加入關鍵字 封面標語: 本書主要在介紹什麼 作者簡介: 照片和名字不一定要真的，大致介紹自己的經歷 內容簡介: 比較詳細的書籍介紹 書籍特色: 列出三到四個特色總覽和簡單說明 小結或許這本書不是厲害到可以讓程式小白成為技術大神。但是寫的當下都在思考 如果回到 2015 年，怎麼樣的學習方式和內容對我來說是最好的。所以不管是語法呈現或是章節編排，其實大大小小改了很多次，目的就是希望這本書真的可以為一些人帶來價值。 如果對書有興趣的話，可以去天瓏翻翻看。有對到妳/你電波 非常歡迎把它帶回家👏👏如果沒辦法到實體門市的話，也可以在以下的網站下單購買喔! 天瓏網路書店 博客來 momo","link":"/blog/%E6%88%90%E5%B0%B1%E8%A7%A3%E9%8E%96/2021111515/"},{"title":"JSDC 2021 | 心得文 | 7 場印象深刻的議程","text":"前言今年是 JSDC 舉辦的第十年。雖然去年開始才關注到這個活動，不過這兩年的參與仍然是讓我學到很多，也同時感受到 JavaScript 各種的可能性。我一直以來只有專注在 Web 前端還有 mobile 上的開發，對於今年提到的區塊鏈、 Serverless 等主題其實很陌生。不過藉由幾場相關的議程分享，讓我至少可以對他們有基本的認識，這應該也是參加這種活動的好處吧! 接下來就整理幾場我印象比較深刻的議程，希望也能為你的開發日常帶來新的靈感與想法🙂 跨平台整合The Future of React: 18 and Beyond 講者: C.T.Lin 關鍵字: React, Streaming Suspense SSR, inline script, Selective Hydration, Concurrent Features, Transition, SuspenseList, Server Components 心得: 透過清楚的流程圖示和簡易的範例程式，可以知道 React 18 之後帶來的重要 features 有哪些。統整這些 features，會發現大多都是給使用者更順暢和更快速的操作體驗。另外也給開發者更大的彈性，像是可以只在部分元件上進行 concurrent rendering，降低開發者在轉換過程中的門檻。 目前可以安裝 react 的 alpha 版試玩最新釋出的功能。 1234567npm install react@alpha react-dom@alpha --save# package.json# &quot;dependencies&quot;: {# &quot;react&quot;: &quot;^18.0.0-alpha-edfe50510-20210823&quot;,# &quot;react-dom&quot;: &quot;^18.0.0-alpha-edfe50510-20210823&quot;# } 從 React Native 跨屏開始的多領域開發歷程 講者: Sam Huang 關鍵字: React Native, 扁平架構, 軟體測試, 開源心態, Bottom Up 心得: 這場主要是講者透過豐富的實務經驗，分享軟硬體開發的心法。雖然沒有接觸軟硬體整合的領域，不過分享的內容也很適合純軟開發上。盡量扁平化資訊架構、善用測試驗證想法、以產出最小可行性的原則來技術選型，還有保持開源和分享的心態，開發者才能像是源源活水般持續往前等等。 最後的總結，其實很常聽到一位資深同事說－「同中取異，異中取同」。小到元件或函式庫開發，大到資訊架構的整合，如果能實踐這句話的精神，應該在開發的這條路上更能如魚得水吧! 區塊鏈應用前端工程師也能搞得懂的區塊鏈 講者: Lucien Lee 關鍵字: BlockChain, P2P Network, Ledger Data Storage, Block Hash Chain, Mine, Decentralized, ETH, POW, Smart Contract, Dapps, Web3.js, RPC, TypeChain, solidity, Arbitrage, Pelith 心得: 這場議程算是區塊鏈中的通識課，就算沒有開發背景的人，也能從講者準備的內容了解區塊鏈的核心概念以及智能合約的生成機制。那麼 JavaScript 跟區塊鏈應用有什麼關係呢? 講者主要提了以下兩點－ 對使用者來說，他們需要能將複雜的數據清楚呈現的介面，並提供良好的使用者體驗。 對開發單位來說，他們不希望將產生智能合約的邏輯和運算量統攬在後端上，造成龐大的負擔。因此希望使用者在前端上的互動過程中，就可以分擔部分的工作。 因此前端開發在區塊鏈應用的地位是很重要的，如果對區塊鏈有基本認識的前端工程師，也可以挑戰看看。據說目前這個市場還是很缺人，待遇應該可以談得不錯XD JS在生成式、演算藝術與NFT的應用 講者: 吳哲宇 關鍵字: 生成式藝術, p5.js, openprocessing, three.js, Pixi.js, Paper.js, Phasor.js, Artblocks, OSC, socket.io, IoT, Johnny-Five, Node-RED, MaxMSP, TensorFlow.js, ml5.js, 心得: 這個議程可以說是今年最令人耳目一新的主題，很難想像用 JavaScript 就能進行圖像創作，更難想像這種藝術還可以跟區塊鏈、IoT、機器學習等專業領域搭的上。或許我一輩子也用不到這些 skill sets，不過聽完這場議程還是很過癮，至少以後看到這種玩意兒不會被嚇到😆 最近因為玻璃心這首歌重新關注黃明志，最近他為了 NFT 寫了一首歌，而且只放在 NFT 平台上販售，藉此想挑戰傳統的YouTube等平台。為了表示決心，他還在影片中展示把原始的歌曲檔案移除(雖然還是可以救援回來XD)，真狂! 前端開發與框架為什麼許多公司都願意導入 Next.js 講者: Leo 關鍵字: Next.js, CSR, second wave of indexing, SEO, SSR, 圖片載入優化, code-spliting, Hybrid, SSG, file-based routing, pre-rendering 心得: 我還蠻喜歡這個準備這個議程的內容與進行方式。我們或許都知道 CSR 有什麼缺點，導入像 Next.js 這種架構的話可以解決什麼問題等等。不過除此之外，講者也分享了適合應用的場景，還有風險考量等等，並不是要聽的人全盤接受。這種思維在其他語言或是框架的選擇上也很適用。 藉由這個議程可以認識 Next.js 幾個還蠻 strong 的features，像是優化圖片的載入和 file-based routing。雖然目前還沒有機會可以使用 Next.js，希望以後會有適合的專案來進一步熟悉它。 語言特性與後端技術從前端邁向全端 - 前端開發者不該錯過的 Serverless 技術 講者: Kyle Mo(老莫) 關鍵字: Serverless, SSR, BFF, Microservice, API Gateway Pattern, 心得: 雖然還沒接觸過 Serverless，不過我的感受是，它很適合一些開發情境，像是－ 單打獨鬥的前端開發者，可以在基礎建設的建置上不用踩太深的坑 想花最小的資源，建立 MVP 的產品或服務來試水溫 用最小的學習成本，體驗 cloud providers 帶來的便利與好處 Serverless 乍聽之下，好像是指可以把後端拋諸腦後，開心做前端就可以了，其實不是。Serverless 比較像是提供一個相對簡單的介面，去組合想要的後端架構與服務，所以對後端還是要有一定的的瞭解。 除了共筆以外，這篇文章也寫得蠻清楚的，讓第一次聽到 Serverless 的我也能熟悉相關的概念，推推! Memory Leak 與你的距離 講者: Kuan 關鍵字: Memory leak, Heap, Stack, Garbage Collection, DevTool 心得: Memory leak 應該是不少人，包括我自己都有碰過的效能大boss之一😣 講者用程式碼加上流程圖示說明記憶體儲存資料的結構與機制，接著介紹在 V8 中的兩種 GC，之後 demo 如何透過測試工具找出可能會 Memory leak 的程式碼。整體來說可以幫助大家更了解底層的運作方式，覺得收穫滿滿! 另外我也有看了文字版的部分，講者以實務上遇到的問題，透過除錯和測試工具找出發生 Memory leak 的地方。看完之後除了可以具體了解找出問題的執行方式，也更有動力面對這個 Memory leak 大魔王啦! 小結在整理這篇心得文的時候，其實很多地方都是透過共筆的內容去回憶的。參與共筆的人都超厲害，該筆記或該截圖的地方都有放上去，甚至有些議程的共筆還有逐字稿😲 真心感謝這些善心人士的貢獻，讓這篇文章不會難產太久😆 剩下不到一個月的時間就要迎接 2022 了。回過頭來看，今年可以說是我的社群元年，無論是過程中的付出或是收穫都是種新鮮的體驗。期待接下來還能出現更多的火花，為自己或為社群帶來些改變🎉","link":"/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2021120210/"},{"title":"第一次的轉職 | 6 年的工作回顧 | 嘉實資訊 SysJust","text":"2022 年 3 月，我離開了人生中的第一份正職。這份工作讓我從零開始學習當一位軟體工程師。雖然稱不上是厲害，不過點到了一些前端技能，還有熟悉資訊業的職場生態。趁現在記憶猶新，回顧一下這幾年的工作內容，希望透過這篇文章，幫助自己在接下來的路上有更明確的方向。 重點專案回顧在嘉實的開發方式，比較像是接案型態，每個專案基本上是獨立的產品或服務。不過有些彼此是有關連的，所以有時候會有多個項目並行或前後緊接著開發。 2017-2020 我的筆記－XQnote ⛏ &nbsp; Chrome Extension&nbsp;|&nbsp;React&nbsp;|&nbsp;Redux&nbsp;|&nbsp;Web API&nbsp;|&nbsp;Ajax&nbsp;|&nbsp;Webpack&nbsp;|&nbsp;Babel&nbsp;|&nbsp;Tinymce 這算是我的啟蒙專案，除了開始熟悉 JavaScript 的語法，對於開發 Web applications 需要碰到的 Web API、非同步機制等也有基礎的認識。Modern Web 正開始崛起，所以在 mentor 的指導下，導入了 React、Redux、Webpack、Babel 等來建立專案。 由於要做一個在 Chrome 上運行的擴充功能，所以也要學習看官方文件，熟悉開發和上架規範等，同時還需要使用一些第三方套件，像是 rich-text editor 的 Tinymce、找出內文的演算法的 Readability 等。那時候的我沒有什麼經驗，在短時間內需要上手的東西也很多，所以回頭看那時候寫的程式時，其實可讀性很差，要維護或擴展功能的話會很辛苦。 chrome web store XQ 官網介紹 2017-2022 service API ⛏ &nbsp; Node.js&nbsp;|&nbsp;Express 這個項目很簡單，只有一個 API 的 entrypoint，並且用 get 的方式傳入參數，做完頁面的請求跟資料處理後，再回傳 json 格式的結果。這是第一個（也是最後一個 XD) 純後端的專案，雖然 scope 很小，不過至少熟悉了 Node.js 的 middleware pattern，也走了一次基本的 API 開發流程。這也讓我更加清楚自己的開發偏好還是在前端上😆 2018-2019 MoneyDJ－美股特別股/債券專區 ⛏ &nbsp; Vanilla JS&nbsp;|&nbsp;CSS&nbsp;|&nbsp;PHP&nbsp;|&nbsp;Smarty&nbsp;|&nbsp;SQL Stored Procedures 美股特別股是掌握度最低的專案😅 基本上有關 PHP、Smarty 跟 SQL Stored Procedures 的部分都是照著前 owner 的開發模式來擴充。不過有些功能是需要使用 JS 開發的，所以算是對 JavaScript 本身多了一些實務經驗。 美股特別股 債券專區 2019-2021 員工內網 ⛏ &nbsp; React&nbsp;|&nbsp;TypeScript&nbsp;|&nbsp;Matrial UI 在啟動這個專案時，React 剛推出了 functional component，以及 hook pattern 做資料狀態的處理，mentor 在那時候正在內部推 TypeScript，所以藉由這個專案將這兩個技術一起上手。 開發過程其實還蠻愉快的，時程很寬鬆以外，也可以從參與蠻多的功能討論，實作上也可以彈性地選擇要先做什麼 feature。不過回過頭看，我會希望跟後端有更多的溝通，並且在 API 串接的規劃可以再完善一點，避免前端有太多的 legacy code，導致維護上的困難。 2020-2021 XSHighlight 元件 ⛏ &nbsp; React&nbsp;|&nbsp;TypeScript&nbsp;|&nbsp;Storybook&nbsp;|&nbsp;Jest 這個專案是開發一個獨立的元件，讓每個有顯示 XS 語法（公司開發的程式交易語言）的網站可以引用，讓語法呈現高亮，以及提供一些互動操作。其中元件的測試跟文件化，對於規模比較大的專案來說雖然相對單純，但也特別重要，因為使用者就是其他的開發者，除了會去看文件了解使用方式，也需要提供測試來確保元件的品質。 我還蠻慶幸有接下這個專案，對於如何發布元件的開發方式和流程有了基本的了解。 2020-2021 今日財經－AP ⛏ &nbsp; React&nbsp;|&nbsp;TypeScript&nbsp;|&nbsp;NSwagStudio&nbsp;|&nbsp;SCSS&nbsp;|&nbsp;TestCafe&nbsp;|&nbsp;Cucumber&nbsp;|&nbsp;Commitizen 今日財經主要提供瀏覽各家財經新聞，以及個人化的功能。目前在 XQ 全球贏家 或合作券商的報價軟體上都可以使用這項服務。 這算是我的實驗專案，只要是當時想學的技術都會走過一輪。像是使用 TestCafe、Cypress、Cucumber 進行 e2e 測試；使用 Yarn workspaces 把專案用 monorepo 的方式管理；使用 commitizen 跟 cz-lerna-changelog 規範 commit 格式；使用 NSwagStudio 自動轉出 TS 版的 API entrypoint；精進 React 跟 TypeScript 寫法，像是 HOC、 Context API、Generics 等等。所以開發這個專案的期間也是技能樹點最多的時候。 2021-2022 今日財經－APP ⛏ &nbsp; React Native&nbsp;|&nbsp;fastlane 開發 APP 跟開發 Web 應用的歷程差很多，從環境建置就會遇到一些挑戰，到後面功能開發的時候，更常碰到各平台的難題需要克服，最後在發布上也有很多細節要掌握。說真的那種遇到未知問題的煩惱會很煩躁，不過當解決問題，還有看到新功能隨著新版本上架的當下會蠻有成就感的。所以有機會的話，還是會想嘗試看看做 APP 相關的專案。 相關文章：行動應用｜自動化開發階段的更版流程｜fastlane｜conventional-changelog iOS App Store Android Google Play 2021-2022 部落格 ⛏ &nbsp; Wordpress&nbsp;|&nbsp;IIS 這個專案雖然跟前端毫無關係ＸＤ 不過這是我最後一個 close 的專案，還蠻有紀念性的，所以還是稍微紀錄一下～ 雖然學生時期有碰過 Wordpress，不過剛開始做的時候還是很生疏，尤其是在 IIS 跟 DB 的部分花了不少心力。幸好主管和同事給了不少 support，最後能如期上線，讓我安全下莊😊 相關文章：WordPress | 架在 IIS 的踩雷紀錄 | Give Me Pretty Permalinks! 小結我很慶幸第一間公司可以在嘉實工作，主管跟同事都人都很好。另外帶我的 mentor 對技術非常地有熱情，所以我也很常被動地認識到新技術或是進階的開發方式等等。比較可惜的地方是我沒有趁這段時間充分使用公司資源跟著上車賺一波學好投資🤣 不過嘉實最近幾年有推出一些 to C 的產品和服務，有空的話會陸續試用看看。學投資理財的同時，也能用另一種方式繼續支持著前公司。 最後也幫前公司宣傳一下，據我所知目前還是有在找人，有興趣的話可以到 LinkedIn 或 104 看更多公司的介紹還有目前有釋出的職位，或是直接問我也可以喔！ LinkedIn","link":"/blog/%E8%81%B7%E6%B6%AF%E7%99%BC%E5%B1%95/2022032211/"},{"title":"[譯] #1 React Query 的實用技巧","text":"本篇文章翻自 Practical React Query謝謝 @TkDodo 撰寫 React Query 的優質系列文，並且開放各方翻譯。 考量到語句通暢性，部分詞句不會完全貼切原意；另外專有名詞會依照個人習慣，適當地翻譯成中文或是維持英文，如果有詞不達意或錯誤的地方歡迎提出 👋 當 GraphQL 和 Apollo Client 大約在 2018 年流行起來時，有不少人認爲 Redux 會被取代，也常有人問 Redux 現在還活著嗎？ 我記得當時對於這樣的狀況有點不解，為什麼 fetch 資料的函式庫會取代狀態管理工具呢？這兩者之間有什麼關係？ 以我的印象，像 Apollo 這樣的 GraphQL client 只會幫你 fetch 資料，就跟 axios 之於 REST API。因此還是需要透過一些方式讓應用可以存取到資料。 但我大錯特錯了。 Client State 和 Server StateApollo 不僅可以讓你描述要抓的資料輪廓，對於這份 Server 來的資料也有 cache 的機制。也就是說當你在多個元件中使用相同的 useQuery hook，Apollo 可以只發出一次的請求取得資料並製作 cache，後續元件要存取這份資料時，Apollo 就以這份 cache 回傳。 這對大家來說其實耳熟能詳，這就像我們用 Redux 在做的事情：從 Server 抓資料，並且在各處可以存取到。 這樣看起來的話，我們其實一直把 Server State 當作是 Client State 來處理。思考一下，你從 Server 抓了文章列表和使用者的詳細資訊等這些資料，你的應用並沒有擁有它們，而是借用它們的最新版本呈現給使用者。Server 才是實際上擁有這些資料的一方。 對我來說，這帶來了全新的思維和典範轉移，讓我重新思考對於資料的處理方式。如果應用本身可以不用擁有資料，就可以適當地使用 cache 機制呈現，就不需要以 Client State 的方式處理，才能讓整個應用都能存取到。這讓我理解為什麼許多人會覺得，在多數情況下，Apollo 可以取代 Redux。 React Query我沒有使用 GraphQL 的經驗。我們有一個既有的 REST API 可以正常運作，也沒有遇過 over-fetching 的問題。顯然並沒有產生足夠的痛點讓我們一定得轉換，尤其是你還得說服後端，這不是件簡單的事。 不過我還是很嚮往前端可以用簡潔的方式抓資料，包括處理載入中和錯誤的狀態，如果這在使用 REST API 的 React 應用之下有類似的 … 讓我們正式進入到 React Query 的環節。 React Query 由開源社群裡的 Tanner Linsley 在 2019 年底發布，並將 Apollo 的優點帶進 REST 的開發模式。它能以任何的函式形式運作，並回傳一個 Promise。React Query 採用 stale-while-revalidate 的 cache 策略，它會以合理的預設設定進行操作，讓你的資料盡可能是最新的狀態，但也盡可能地即時呈現給使用者，提供良好的使用者體驗。最重要的是，當預設的行為無法滿足需求時，React Query 也提供充足的設定進行客製化，相當地彈性。 不過這篇文章並不會對 React Query 進行基本的介紹。 我認為官方文件已經有很好的觀念解釋和語法指示，你可以觀看各種的談話性影片，以及 Tanner 製作的官方課程，你可以藉由以上這些教材來熟悉這個函式庫。 接下來的重點放在一些實用技巧來作為官方文件的延伸，對於已經在用 React Query 的你或許會有點用處。這些實用技巧是我在過去幾個月以來，從工作上或是參與 React Query 社群時，在 Discord 的問答和在 GitHub 中發起的討論整理而來的。 對於預設行為的解釋我相信 React Query 的 預設行為 已經很理想，不過有時候這些行為反而會讓你措手不及、陷入混亂，尤其是新手。 首先，React Query 並不會在每次的渲染下 invoke queryFn，即使 staleTime 是預設的 0。你的應用會在任何時間根據各種原因重新渲染，所以每次的渲染都進行 fetching 是非常不理想的事。 如果你遇到非預期的 refetch，這有可能只是因為當你 focus window 時，React Query 會執行 refetchOnWindowFocus 的事件，這對於正式環境來說是個理想的功能：當使用者從瀏覽器的其他分頁返回你的應用頁時，就會自動觸發背景的更新，當 Server 有資料變動時，畫面上就會顯示最新的資料狀態。上述發生的過程中並不會呈現載入中的 UI，而且如果你的資料是來自 cache 的話，元件也不會重複渲染。 需要注意的是，在開發過程中，我們會頻繁地切換瀏覽器開發工具以及應用頁，這樣的動作也會觸發 refetchOnWindowFocus ，造成更頻繁的 refetch。 再來，對於 staleTime 和 cacheTime 很容易產生混淆 ，所以我試著疏理一下這兩者的意思－ staleTime： query 從有效到過期所經過的時間。只要這份 query 在有效期間內，資料總是會從 cache 中取得，不會發生任何的網路請求。如果這份 query 過期了（預設值為 0，也就是在產生 query 的當下就馬上過期了），你還是會從 cache 中取得資料，不過在 某些條件下 會在背景執行 refetch。 cacheTime： 一旦沒有任何的 observer 註冊（當所有有用到 query 的元件都 unmounted）， query 會進到 inactive 的狀態，然後會隔一段時間後就會從 cache 中清除。預設是 5 分鐘。 使用 React Query 的開發者工具這將會幫助你很好地瞭解 query 的狀態變化。這個開發者工具也可以讓你知道目前 cache 的資料內容是什麼。所以你可以更容易地進行除錯。除此之外，我發現瀏覽器的開發者工具可以對 network connection 進行 throttle，來測試在不同的網路環境下執行背景 refetch 的狀況，畢竟在一般的開發環境下總是很快速。 把 query key 當作是 dependency array在這裡我會引用 useEffect hook 的 dependency array 的觀念來說明，我假設你已經對它熟悉了。 為什麼這兩件事情會很類似呢？ 因為當 query key 變動時，React Query 就會觸發 refetch，所以當我們以一個變數作為 queryFn 的參數時，會希望一旦變數值更新，queryFn 就會執行 fetch 資料的動作。我們可以利用 query key 來做到這件事，而不是組織複雜的 effects 並手動地觸發 refetch。 feature/todos/queries.ts1234567891011121314type State = 'all' | 'open' | 'done'type Todo = { id: number state: State}type Todos = ReadonlyArray&lt;Todo&gt;const fetchTodos = async (state: State): Promise&lt;Todos&gt; =&gt; { const response = await axios.get(`todos/${state}`) return response.data}export const useTodosQuery = (state: State) =&gt; useQuery(['todos', state], () =&gt; fetchTodos(state)) 在這個例子，我們想像畫面呈現待辦事項的列表，並且有篩選的選項。我們會有一些 local state 去儲存篩選後的狀態，一旦使用者切換選項時，我們可以更新 local state。而切換選項會導致 query key 的變動， React Query 將會自動地為我們觸發 refetch。因此我們可以將使用者的篩選選項和對應的 query 函式保持在同步的狀態，這就像是 dependency array 之於 useEffect一樣。 新的 cache entry因為 query key 會被當作 cache key，當你第一次從 ‘all’ 的狀態切換成 ‘done’ 時，就會產生新的 cache entry，並且在過程中產生載入中的狀態（或許畫面會呈現載入中的圖示），這可不理想。所以在這樣的情況中，你可以使用 keepPreviousData 的選項，或者可能的話，以 initialData 預先為這份新的 cache entry 建立初始資料。 pre-filtering12345678910111213141516171819202122type State = 'all' | 'open' | 'done'type Todo = { id: number state: State}type Todos = ReadonlyArray&lt;Todo&gt;const fetchTodos = async (state: State): Promise&lt;Todos&gt; =&gt; { const response = await axios.get(`todos/${state}`) return response.data}export const useTodosQuery = (state: State) =&gt; useQuery(['todos', state], () =&gt; fetchTodos(state), { initialData: () =&gt; { const allTodos = queryClient.getQueryData&lt;Todos&gt;(['todos', 'all']) const filteredData = allTodos?.filter((todo) =&gt; todo.state === state) ?? [] return filteredData.length &gt; 0 ? filteredData : undefined }, }) 將 Server State 與 Client State 保持分離這件事情跟我在上個月寫的文章－putting-props-to-use-state 有密切的相關。如果你從 useQuery 取得資料，那麼不要嘗試將這份資料放進 local state。主要原因是這樣做等同默認你要屏棄所有 React Query 做的機制，因為當你放進 local state 後，你操作的就只是這份資料的「副本」，因此無法進行更新。 不過有些情況是允許這樣做的。例如為表單的欄位 fetch 預設資料，在資料準備就好就渲染表單元件。如果你是刻意要這麼做，請確保避免不必要的背景 refetch，你可以藉由設定 staleTime 來達成。 initial-form-data12345678910const App = () =&gt; { const { data } = useQuery('key', queryFn, { staleTime: Infinity }) return data ? &lt;MyForm initialData={data} /&gt; : null}const MyForm = ({ initialData} ) =&gt; { const [data, setData] = React.useState(initialData) ...} 當你想呈現一份允許使用者進行編輯的資料時，其中有個觀念在實踐上會有點難度。我在 codesandbox 上放了一個範例程式： 在這個 demo 中有一個重點是，我們絕不會把從 React Query 來的值放進 local state 裡。這樣可以確保我們總是可以看到最新的資料，畢竟我們不是用複製到 local state 的方式來呈現。 強大的 enabled 選項useQuery hook 有許多的設定可以客製化它的行為。其中有個 enabled 的選項可以做蠻多很酷的事。在這裡簡單整理以下可以透過這個選項做到的事： 具有相依性的 query：當有多個 query 設定相依性後，前一個 query 必須成功執行並取得資料，下一個 query 才會接續執行。 控制 query 的開關狀態：多虧有 refetchInterval，我們可以讓 query 自動定期地執行。但在某些情況下，例如 UI 顯示 modal 時，為了避免背後的畫面更新，我們可以暫停執行 query。 等待使用者的輸入：在 query key 中有些篩選的標準，不過一旦使用者沒有要採用的話就可以不用。 在某些使用者輸入的情況下不採用 query：我們可以優先使用 draft 值來取代從 Server 來的資料。可以參考上面的 demo。 不要使用 queryCache 作為本地狀態的管理工具如果要自行修改 queryCache（queryClient.setQueryData），你應該只能在符合 optimistic update 的條件下執行，或者進行 mutation 後，以 Server 回傳的資料來寫入。要記住每一次在背景發生 refetch 時都有可能覆蓋到資料，所以請使用其他方式來管理應用本身的狀態（Client State），像是 state hook, zustand, Redux 等等。 建立自訂的 hook就算只是把 useQuery 的呼叫再包一層起來，建立自訂的 hook 還是有好處，原因如以下－ 你可以將實際發生資料請求的行為從 UI 中抽出來，並在 useQuery 中管理。 你可以在一個檔案裡集中所有對同個 query key 的使用（可能還有型別定義）。 如果需要調整一些設定或者對資料進行轉換，你可以集中一個地方實作。 其他參考來源 [npm] react-query | PJCHENder 未整理筆記 React Query Tutorial | 前端癢癢 der","link":"/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2022060716/"},{"title":"[譯] #2 React Query 的資料轉換","text":"本篇文章翻自 React Query Data Transformations謝謝 @TkDodo 撰寫 React Query 的優質系列文，並且開放各方翻譯。 (封面圖由 Joshua Sukoff 提供) 考量到語句通暢性，部分詞句不會完全貼切原意；另外專有名詞會依照個人習慣，適當地翻譯成中文或是維持英文，如果有詞不達意或錯誤的地方歡迎提出 👋 歡迎來到「關於 React Query 我想說的事情」 part 2。由於我參與這個函式庫和相關社群的程度愈來愈深，我觀察到人們常問特定方面的問題。原本我是想要用一篇長文的形式寫完，不過我後來決定將這些問題分門別類，寫成不同的文章。第一篇的主題相當地普遍並且很重要：資料轉換。 資料轉換0. 從後端來看可以達成的話，這會是我最喜歡的方式。如果後端回傳的資料正好符合前端的需求，我們就不用再多做什麼。然而在許多情況下，這聽起來或許不太實際。例如我們需要串接公開的 REST APIs，而且這也有可能在企業級應用中會碰到。如果你對於後端有掌控權，而且可以控制 enpoint 回傳的資料剛好符合你的使用情境，請盡量使用者這個方式。 🟢 無法運用在前端。🔴 並不是百分之百可行。 1. 在 queryFn 中queryFn 是一個你會傳入到 useQuery的函式，並且會希望你回傳一個 Promise。Promise 中的結果資料會被作為 query cache。不過這並不代表你必須完全按照後端的形式回傳。你可以在回傳前先進行轉換，像這樣子： queryFn-transformation12345678const fetchTodos = async (): Promise&lt;Todos&gt; =&gt; { const response = await axios.get('todos') const data: Todos = response.data return data.map((todo) =&gt; todo.name.toUpperCase())}export const useTodosQuery = () =&gt; useQuery(['todos'], fetchTodos) 在前端處理這份資料時，就會有種「這就像是直接從後端取得」的感覺。在你的應用中不需要額外處理那些開頭沒有大寫的代辦項目名稱。不過你會沒有權限去存取於原本的資料結構。如果你看 React Query 的開發者工具，你會看到已經轉換過的資料結構。但如果你看 network 的請求過程，則是會看到原本的資料結構。這或許會令人疑惑，所以先把這樣的方式放在心中吧。 🟢 按照 co-location 的概念，符合因「與後端高度相關」，所以盡可能放置在靠近抓資料的地方。🟡 資料會在存入 cache 前就轉換完成，所以你沒有權限存取原本的資料結構。🔴 每次進行 fetch 時都會執行到。🔴 如果你有共用 api 層的設計，而且無法輕易修改的話，這方式並不可行。 2. 在 render 中在 Part 1 的建議中有提到，如果你建立自訂的 hooks，你可以輕易地對資料進行轉換： render-transformation12345678910111213const fetchTodos = async (): Promise&lt;Todos&gt; =&gt; { const response = await axios.get('todos') return response.data}export const useTodosQuery = () =&gt; { const queryInfo = useQuery(['todos'], fetchTodos) return { ...queryInfo, data: queryInfo.data?.map((todo) =&gt; todo.name.toUpperCase()), }} 以目前來說，這不僅會在每次執行 fetch 時就轉換一次，還會在每次的渲染時（甚至有些渲染跟抓資料並沒有關係）也會執行到。這可能根本不是個問題，但如果是的話，你可以使用 useMemo 進行優化。需要注意的是，定義的 dependencies 盡量是愈少愈好。在 queryInfo 裡的 data會是穩定不變的，一直到某些東西改變（在這種情況下你會想要重新轉換得到新的資料）。__ useMemo-dependencies123456789101112131415161718export const useTodosQuery = () =&gt; { const queryInfo = useQuery(['todos'], fetchTodos) return { ...queryInfo, // 🚨 don't do this - the useMemo does nothing at all here! data: React.useMemo( () =&gt; queryInfo.data?.map((todo) =&gt; todo.name.toUpperCase()), [queryInfo] ), // ✅ correctly memoizes by queryInfo.data data: React.useMemo( () =&gt; queryInfo.data?.map((todo) =&gt; todo.name.toUpperCase()), [queryInfo.data] ), }} 這會是個理想的方式，尤其是你需要在自訂 hook 裡加入額外的邏輯來處理資料轉換時。但是需要注意資料有可能是 undefined，所以請使用 optional chaining 來處理。 🟢 透過 useMemo 優化。🟡 開發者工具無法檢查到最後精確的資料結構。🔴 語法會有點迂迴。🔴 資料有可能會是 undefined。 3. 使用 select 選項在 v3 有引入了內建的選擇器（selectors），我們可以用它來進行資料的轉換： select-transformation1234export const useTodosQuery = () =&gt; useQuery(['todos'], fetchTodos, { select: (data) =&gt; data.map((todo) =&gt; todo.name.toUpperCase()), }) 當 data 存在時，選擇器才會被呼叫到，所以你不用擔心 undefined 的情況。以上述例子的選擇器來說，由於每次渲染時函式實體都會改變（它是 inline 函式），所以在每次渲染時都會執行到。如果你的資料轉換的成本很高（需要進行複雜的運算），你可以 memoize 選擇器函式，像是使用 useCallback 或者讓他參考到既有的函式實體。 select-memoizations1234567891011121314151617const transformTodoNames = (data: Todos) =&gt; data.map((todo) =&gt; todo.name.toUpperCase())export const useTodosQuery = () =&gt; useQuery(['todos'], fetchTodos, { // ✅ uses a stable function reference select: transformTodoNames, })export const useTodosQuery = () =&gt; useQuery(['todos'], fetchTodos, { // ✅ memoizes with useCallback select: React.useCallback( (data: Todos) =&gt; data.map((todo) =&gt; todo.name.toUpperCase()), [] ), }) 除此之外，select 選項可以用來只訂閱部分的資料。這也是這個方式獨特的地方。思考以下的範例程式： select-partial-subscriptions123456export const useTodosQuery = (select) =&gt; useQuery(['todos'], fetchTodos, { select })export const useTodosCount = () =&gt; useTodosQuery((data) =&gt; data.length)export const useTodo = (id) =&gt; useTodosQuery((data) =&gt; data.find((todo) =&gt; todo.id === id)) 在這裡，我們建立了類似 Redux－useSelector 的 API，並且呼叫了 useTodosQuery 以及傳入自訂的選擇器。如果你沒有傳入自訂的選擇器，這個自訂 hook 一樣可以運作，他會回傳所有的資料狀態。 不過如果你傳入一個選擇器，你就只會訂閱到這個選擇器函式的執行結果。這會非常的強大，因為這代表即使我們更新某個待辦項目的名稱，只有透過 useTodosCount 訂閱待辦項目的數量的元件並不會被重新渲染。由於數量的值並沒有改變，所以 React Query 可以選擇不要通知觀察者更新 🥳 (請注意一下這裡是簡化過的說明，就技術上來說並不完全正確－我會在 Part 3 說得更仔細)。 🟢 最好的優化方式。🟢 可以允許部分的訂閱。🟡 可以根據不同的觀察者組織不同的轉換方式。🟡 結構式共享會被執行兩次(我會在 Part 3 提到更多細節)。","link":"/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2022060818/"},{"title":"[譯] #3 React Query 的優化","text":"本篇文章翻自 React Query Render Optimizations謝謝 @TkDodo 撰寫 React Query 的優質系列文，並且開放各方翻譯。 (封面圖由 Lukasz Szmigiel 提供) 聲明：在任何的應用裡，優化渲染的部分是屬於進階的概念。React Query 在原生上已經有非常好的優化和預設行為，所以不需要再進一步地優化。許多人會放不少心思在「不需要的重複渲染」的主題上，這也是我決定要整理這篇文章的原因。不過我想重申一次，在大部分的應用中，優化渲染或許並沒有你想像中的茲事體大。重複渲染是件好事。他會讓你的應用總是在最新的狀態。相對於「缺少應該要有的渲染」，我更加可以接受「不必要的重複渲染」。關於這個主題的更多延伸，請閱讀以下兩篇文章： Fix the slow render before you fix the re-render this article by @ryanflorence about premature optimizations 當我在 [譯] #2 React Query 的資料轉換中說明 select 選項時，已經有稍微帶到效能優化的部分。然而，「就算資料沒有改變，為什麼 React Query 還是會重複渲染元件」這個問題是我最常被問到的。所以讓我再試著深入解釋。 isFetching 的轉換我必須要誠實地說，在上個例子中有說過只當有待辦項目的數量變動時，元件才會再次渲染。 count-component123456789export const useTodosQuery = (select) =&gt; useQuery(['todos'], fetchTodos, { select })export const useTodosCount = () =&gt; useTodosQuery((data) =&gt; data.length)function TodosCount() { const todosCount = useTodosCount() return &lt;div&gt;{todosCount.data}&lt;/div&gt;} 每次在做背景的 refetch 時，元件會根據以下的 query 資訊重複渲染兩次： 12{ status: 'success', data: 2, isFetching: true }{ status: 'success', data: 2, isFetching: false } 這是因為 React Query 對於每個 query 會暴露許多 meta 資訊，isFetching 就是其中之一。當資料請求還在進行中的時候，這個 flag 就會維持 true。如果你想要在這種時候在畫面的背景中呈現載入中的指示時，這個會相當好用。不過如果你不用特別呈現載入中狀態的話，這個就會有點不太需要。 notifyOnChangeProps針對這樣的情況，React Query 有提供 notifyOnChangeProps 的選項。這個會在每個觀察者中進行指定，告訴 React Query 說，只有列表中的任一 prop 有更新，才需要通知觀察者這次的變動。藉由把設定這個選項設成 [data]，我們就能達到想要的優化。 optimized-with-notifyOnChangeProps1234export const useTodosQuery = (select, notifyOnChangeProps) =&gt; useQuery(['todos'], fetchTodos, { select, notifyOnChangeProps })export const useTodosCount = () =&gt; useTodosQuery((data) =&gt; data.length, ['data']) 你可以在文件中的例子－optimistic-updates-typescript 看到實際的應用。 保持同步（sync）雖然以上的方式可以很好地運作，但是容易產生不同步的情況。但如果我們也想對錯誤進行反應的話該怎麼辦呢？或者我們想開始用 isLoading 的 flag？我們必須要讓 notifyOnChangeProps 裡的列表和我們在元件中實際使用的地方保持同步。如果我們忘記這件事，只有觀察到 data，但在渲染我們有用到 error。一旦有錯誤時，我們的元件並不會重複渲染。如果在我們自訂的 hook hard-code 的話會特別的麻煩，因為這個 hook 並不會知道元件實際上會運用到什麼： outdated-component1234567891011121314export const useTodosCount = () =&gt; useTodosQuery((data) =&gt; data.length, ['data'])function TodosCount() { // 🚨 we are using error, but we are not getting notified if error changes! const { error, data } = useTodosCount() return ( &lt;div&gt; {error ? error : null} {data ? data : null} &lt;/div&gt; )} Tracked Queries我非常地以這個 feature 自豪，因為這是我在這個函式庫中第一個主要的貢獻。如果你把 notifyOnChangeProps 設成 tracked，React Query 會對在渲染過程中會用到的欄位持續地追蹤。你也可以在全域開啟這個選項讓全部的 queries 適用這項設定。 tracked-queries1234567891011121314const queryClient = new QueryClient({ defaultOptions: { queries: { notifyOnChangeProps: 'tracked', }, },})function App() { return ( &lt;QueryClientProvider client={queryClient}&gt; &lt;Example /&gt; &lt;/QueryClientProvider&gt; )} 有了這個，你再也不用思考有關重複渲染的事情。當然，追蹤使用到的欄位會需要花些運算的成本，所以當你要廣泛使用的話要確認一下。Tracked queries 也有一些限制，這也是為什麼這是的選用的 feature： 如果你使用物件的剩餘運算子進行解構，你會有效地觀察到每個欄位。一般的解構可以正常運作，只要做要做這件事： problematic-rest-destructuring12345// 🚨 will track all fieldsconst { isLoading, ...queryInfo } = useQuery(...)// ✅ this is totally fineconst { isLoading, data } = useQuery(...) Tracked queries 只會在「渲染過程中」作用。如果你只是想在進行 effects 的時候存取欄位，這些欄位並不會被追蹤。以下是個邊際案例： tracking-effects1234567891011const queryInfo = useQuery(...)// 🚨 will not corectly track dataReact.useEffect(() =&gt; { console.log(queryInfo.data)})// ✅ fine because the dependency array is accessed during renderReact.useEffect(() =&gt; { console.log(queryInfo.data)}, [queryInfo.data]) Tracked queries 在每次的渲染並不會進行重置。因此一旦你追蹤了某個欄位，在觀察者的存活期間，你將會持續地追蹤他。 no-reset123456const queryInfo = useQuery(...)if (someCondition()) { // 🟡 we will track the data field if someCondition was true in any previous render cycle return &lt;div&gt;{queryInfo.data}&lt;/div&gt;} 更新：從 v4 開始，在 React Query 的預設行為中，tracked queries 會被開啟。你可以透過設定 notifyOnChangeProps: 'all' 選擇性地關閉這個 feature。 結構性共享（Structural sharing）雖然是不同的事情，但是跟渲染優化一樣重要，並且在 React Query 中預設開啟支援的是「結構性共享（Structural sharing）」。這個 feature 會確保我們在每個層級中，都能持續地參考到資料的實體。在這個範例中，假設你擁有以下這樣的資料結構： 1234[ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Learn React&quot;, &quot;status&quot;: &quot;active&quot; }, { &quot;id&quot;: 2, &quot;name&quot;: &quot;Learn React Query&quot;, &quot;status&quot;: &quot;todo&quot; }] 現在，假設我們將第一個待辦項目的 status 轉換成 done，並且我們要在背景 refetch。我們將會從後端取得完整全新的資料： 12345[- { &quot;id&quot;: 1, &quot;name&quot;: &quot;Learn React&quot;, &quot;status&quot;: &quot;active&quot; },+ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Learn React&quot;, &quot;status&quot;: &quot;done&quot; }, { &quot;id&quot;: 2, &quot;name&quot;: &quot;Learn React Query&quot;, &quot;status&quot;: &quot;todo&quot; }] 現在 React Query 將會試圖比較新的跟舊的資料，並且盡可能地維持之前的狀態。在我們的例子中，這個待辦項目的陣列將會是以新的為主，因為我們更新了一個待辦項目。 id 為 1 的物件將會是新的，不過 id 為 2 的物件將會跟之前的狀態是一致的參考－因為他並沒有產生任何變動，React Query 只會把參考複製到新的結果上。 當我們要部分訂閱資料時，使用 selectors 會非常地方便： optimized-selectors123// ✅ will only re-render if _something_ within todo with id:2 changes// thanks to structural sharingconst { data } = useTodo(2) 如同我之前提示過的，對於 selector 來說，結構性共享會執行兩次：一次是根據 queryFn 回傳的結果來判斷是否有任何變動；再一次是 selector 函式回傳的結果。在某些情況下，尤其是當有非常龐大的資料集時，結構性共享反而會成為效能瓶頸。如果你不需要這項優化，你可以在任何的 query 中設定 structuralSharing: false 來關閉。 如果你想要了解背後運作的原理，可以看這個 replaceEqualDeep tests。","link":"/blog/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/2022061017/"},{"title":"第一年的工作回顧 | 熱鬧點科技 Migo","text":"從 2022 年 4 月加入 Migo 到現在不到一年，應該是還在全力衝刺的階段，不過因為一些衝擊和不確定性，我決定先來回顧在 Migo 做了哪些成果，以及一些想法和心得。希望透過這篇的整理，幫助自己釐清接下來的職涯方向。 工作模式彈性遠端一開始因為 on-boarding sessions 的關係，前兩個禮拜都會進辦公室。不過因為疫情關係，加上公司對於 WFH 的彈性也愈來愈大，所以漸漸地變成幾乎都在家上班，有參加活動或重要事情時才會進辦公室ＸＤ 我對於 WFH 的工作型態其實適應了一段時間。老實說我並不是很有自律力，加上在家裡很容易被突如其來的事情干擾。有陣子我有嘗試去咖啡廳做正事，雖然專注力有提升一點，不過後來覺得還是有些不方便（每次都要膽戰心驚地去洗手間，連伸個懶腰也很難不自在ＸＤ），後來還是回來家裡工作😅 為了改善工作效率，我決定重拾在前公司的習慣，透過 notion 建立 weekly agenda 安排每週的計畫與任務，最近也嘗試寫間歇式筆記，試著讓工作在日常生活中的分配更加具體，也可以更聚焦在目標上。 我覺得習慣之後，彈性遠端會是個很理想的工作型態，每天可以減少快兩個小時的通勤時間，也可以更有彈性地安排工作或個人的行程。比較明顯的缺點應該就是減少很多跟外界的接觸，需要主動地參與一些活動或社群，才不會整個疏離人群，產生社交障礙ＸＤ 團隊協作與溝通ClickUp 是團隊主要使用的專案管理工具，使用起來還算順手，可以集中 user stories 、 tasks 和 issues 在專案的 space 裡，提供的欄位和功能也算多。 Slack 是遠端工作時最重要的溝通工具，不用特地約 meeting 跟會議室，直接用 huddle 就可以即時跟一人或多人討論，甚至可以雙向分享螢幕，真的很厲害（huddle pending 時放的音樂我也很愛ＸＤ）。另外可以建立跟 devops 或開發相關的 channel，可以幫助 workflow 的自動化和開發過程更順暢。 OKR &amp; Reviews每一季都以 OKR 的準則訂定想完成的目標和實踐方式，使用的工具是 Lattice。除了兩個禮拜一次跟主管的 1 on 1，還有半年一次的 Performance/Peer Review。整體來說我覺得還算不錯，可以確保在工作上做的事情都可以 align 到自己的目標，也能評估自己是否有實踐任務的進度。 不過過程中比較有問題的是，目標的設立基本上要 align 到公司當季的發展重點或核心項目。但是在這段期間，公司並沒有訂定明確的大目標，讓各層級的職責角色有個根據來訂定自己的目標。所以比較難衡量自己的目標對於公司來說到底有多少貢獻。 專案回顧元件庫 ⛏ &nbsp; Nx&nbsp;|&nbsp;React&nbsp;|&nbsp;TypeScript&nbsp;|&nbsp;SASS&nbsp;|&nbsp;emotion&nbsp;|&nbsp;GitLab&nbsp;|&nbsp;npm&nbsp;|&nbsp;Storybook 這是我在前公司時就很想做的專案，我很開心在這裡可以完成這個理想，甚至還幫這個專案取名叫做 paintbox，希望這個元件庫就像顏料盒一樣，可以讓專案開發的人花更少的時間，透過元件的彈性組合，來完成每個應用。 一開始在研究 monorepo 的實作方式時，發現了強大的 Nx，沒多久後還釋出收購 Lerna 的消息。因此決定用這個工具來建構，同時大量地使用 Storybook 進行元件的視覺化和文件化。 目前在 paintbox 裡不只有 react 元件，也集中專案間常用的 helper 跟 utility，可以增加 codebase 的品質和維護性。另外 registry 的部分則是選擇公司內部就有的 infra－ GitLab 的 Package Registry，使用起來的體驗還不錯，不用再額外維護像 Verdaccio 的環境，減少維護的成本。 影片資訊頁 / App Landing Page ⛏ &nbsp; Next.js&nbsp;|&nbsp;React&nbsp;|&nbsp;TypeScript&nbsp;|&nbsp;SASS&nbsp;|&nbsp;Ansible&nbsp;|&nbsp;Google Map API 這個專案一開始原本是做影片資訊頁的 prototype，考慮到專案的特性跟需求，所以選擇 Next.js 進行 SSR。不過後來有另外一個專案是做 App Landing Page，考量到這兩個專案是可以做統整在同個應用中，就像 Netdflix 或 Desney+ 等 OTT 平台一樣，所以就沿用這個專案來做。 雖然 UI 上很單純，不過還要加上 GA Tracking、Google Map API 的 integration，跟各個團隊有蠻多的一來一往，所以也花了點心力完成這個項目。不過基本上也在理想的時間內 deliver。 App Landing Page 內部系統 ⛏ &nbsp; React&nbsp;|&nbsp;TanStack/table&nbsp;|&nbsp;TanStack/query&nbsp;|&nbsp;Vue&nbsp;|&nbsp;TypeScript&nbsp;|&nbsp;SASS&nbsp;|&nbsp;Ansible&nbsp;|&nbsp;Docker&nbsp;|&nbsp;AWS&nbsp;|&nbsp;Storybook 目前開發或維護過的內部系統大致分以下三類－ 帳務管理：像是制定影片的期間價格等 影音內容管理：管理影片相關的 assets、發布狀態等 hotspot 相關：Migo 的核心技術之一是可以讓使用者連進附近的 hotspot，不用花費自己的網路就可以下載大流量的影片。而 hotspot 從組裝、安裝到合作店家到資料的同步和維護等都需要不同的系統進行設定 這類型的專案是在 Migo 中最常碰到的。由於是內部系統，對於 UI/UX 的要求沒那麼高，時程也比較有彈性。因此可以多花點心力在研究新技術的導入和實驗，並且一步步建立專案開發的流程、架構和文件化。 帶 junior 的初體驗第一次帶 junior 其實比想像中順利很多。比起單向地提供 junior feedback，我是偏向用「如何讓他也成為 senior」的心態來帶。工作分配除了依照自身能力和經驗以外，也會以對專案的熟悉度，互相討論分工，所以合作起來也蠻順暢的。 當 junior 卡關或是有問題反應時，我會直接跟他 huddle 一起解決，希望能縮短瓶頸的時間。過程中我也獲得不少解決問題的經驗，對我來說也是一種學習。另外我們也在 Notion 上共同經營 frontend tech resources page，不定期地分享自己看到的技術資源，我很喜歡這樣的學習方式，除了比較不孤單，也能發揮 1+1 &gt; 2 的效益。 後記從剛進去到 11 月左右時，我並沒有對公司的營運狀況有什麼疑問，從 all-hands 中分享印尼的使用者回饋和業務的擴展規模來看，我也抱著很美好的想像，相信這樣的商業模式不僅可以幫助到當地收入不高的人，也相信將來會推動到其他開發中國家，像是菲律賓、印度等，擴張公司發展的版圖。 直到 11 月底台灣辦公室突然大量 layoff ，有些同事甚至 leadership 陸續離開，我才認真去了解公司背後的結構和財務問題。雖然 CEO 不斷地向大家信心喊話，保證可以度過眼前的難關。但當碰到人生第一次的欠薪時，我決定認清現實，提早規劃職涯的下一階段，同時也反省自己在轉職和工作期間是否有產生遲鈍和疏忽的地方。 不過我並不後悔決定來 Migo，如果繼續待在前公司，會比較難接收到不一樣的刺激和開發文化、學到新的技術。我很喜歡 Migo 的同事跟主管們，大家都很 open mind，彼此交流各自擅長的地方。也因為這份工作，證明了我有身為資深前端的價值。 雖然接下來要面對各種考驗，也不知道下一步我會在哪裡，但是打完這篇回顧後，原本有點焦慮的心理終於有點踏實感，讓我知道自己還是有在前進的。希望跟我同樣正在叉路的你，能夠多少掃除一些迷茫，走出適合自己的路。","link":"/blog/%E8%81%B7%E6%B6%AF%E7%99%BC%E5%B1%95/2023010913/"}],"tags":[{"name":"fastlane","slug":"fastlane","link":"/blog/tags/fastlane/"},{"name":"React Native","slug":"React-Native","link":"/blog/tags/React-Native/"},{"name":"API","slug":"API","link":"/blog/tags/API/"},{"name":"MSW","slug":"MSW","link":"/blog/tags/MSW/"},{"name":"JavaScript","slug":"JavaScript","link":"/blog/tags/JavaScript/"},{"name":"ModernWeb","slug":"ModernWeb","link":"/blog/tags/ModernWeb/"},{"name":"ECMAScript","slug":"ECMAScript","link":"/blog/tags/ECMAScript/"},{"name":"JSDC","slug":"JSDC","link":"/blog/tags/JSDC/"},{"name":"WordPress","slug":"WordPress","link":"/blog/tags/WordPress/"},{"name":"ECMAScript關鍵30天","slug":"ECMAScript關鍵30天","link":"/blog/tags/ECMAScript%E9%97%9C%E9%8D%B530%E5%A4%A9/"},{"name":"React Query","slug":"React-Query","link":"/blog/tags/React-Query/"}],"categories":[{"name":"軟體開發","slug":"軟體開發","link":"/blog/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"},{"name":"成就解鎖","slug":"成就解鎖","link":"/blog/categories/%E6%88%90%E5%B0%B1%E8%A7%A3%E9%8E%96/"},{"name":"職涯發展","slug":"職涯發展","link":"/blog/categories/%E8%81%B7%E6%B6%AF%E7%99%BC%E5%B1%95/"}]}